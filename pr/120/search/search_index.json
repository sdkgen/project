{"config":{"lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conhecendo o sdkgen O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada \"sdkgen\". Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados. Recursos Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha. Caracter\u00edsticas O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma assincrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Conhecendo o sdkgen"},{"location":"#conhecendo-o-sdkgen","text":"O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada \"sdkgen\". Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados.","title":"Conhecendo o sdkgen"},{"location":"#recursos","text":"Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha.","title":"Recursos"},{"location":"#caracteristicas","text":"O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma assincrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Caracter\u00edsticas"},{"location":"descrevendo-api/","text":"Descrevendo uma API API's do sdkgen s\u00e3o descritas em um arquivo .sdkgen . O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o. Tipos primitivos O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas. Tipo Descri\u00e7\u00e3o string Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8. int Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647. uint Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295. bigint Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso. float Um n\u00famero de ponto flutuante de 64 bits, similar ao double do C. money Um n\u00famero inteiro com precis\u00e3o extendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras bool Ou true ou false . json Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora null possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser null diretamente. Para isso utilize json? . date Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize datetime . datetime Representa um instante no tempo com precis\u00e3o de milisegundos. Este instante ser\u00e1 sempre traduzido para a time zone local do recebedor da mensagem. bytes Uma sequencia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios. base64 Similar a uma string , mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida. url Similar a uma string , mas contendo uma URL v\u00e1lida. hex Similar a uma string , mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes. uuid Similar a uma string , mas contendo um UUID v\u00e1lido. email Similar a uma string , mas contendo um email v\u00e1lido. xml Similar a uma string , mas contendo um XML v\u00e1lido. html Similar a uma string , mas contendo um HTML v\u00e1lido. cpf Similar a uma string , mas contendo um CPF v\u00e1lido. cnpj Similar a uma string , mas contendo um CNPJ v\u00e1lido. Modificadores de tipo O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: ? e [] . Todos os tipos s\u00e3o por padr\u00e3o requeridos, com null n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com ? . Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que null se torna um valor aceit\u00e1vel. Por exemplo: string? aceita qualquer texto livre ou null . O modificador [] pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array , na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: cpf[] denota uma lista de CPF's v\u00e1lidos. Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: int[]? significa ou null ou uma lista de int 's. string[][] significa uma lista de listas de string 's. bool?[] significa uma lista de ou true ou false ou null . Tipos compostos Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo: { name: string age: uint } Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo optionais, listas ou outros objetos. Por exemplo: { id: uuid name: string avatar: url? friends: { id: uuid name: string }[] } Enum Em adi\u00e7\u00e3o aos tipos anteriores um enum representa um conjunto limitado de possibilidades de valores. Por padr\u00e3o os","title":"Descrevendo uma API"},{"location":"descrevendo-api/#descrevendo-uma-api","text":"API's do sdkgen s\u00e3o descritas em um arquivo .sdkgen . O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o.","title":"Descrevendo uma API"},{"location":"descrevendo-api/#tipos-primitivos","text":"O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas. Tipo Descri\u00e7\u00e3o string Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8. int Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647. uint Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295. bigint Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso. float Um n\u00famero de ponto flutuante de 64 bits, similar ao double do C. money Um n\u00famero inteiro com precis\u00e3o extendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras bool Ou true ou false . json Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora null possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser null diretamente. Para isso utilize json? . date Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize datetime . datetime Representa um instante no tempo com precis\u00e3o de milisegundos. Este instante ser\u00e1 sempre traduzido para a time zone local do recebedor da mensagem. bytes Uma sequencia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios. base64 Similar a uma string , mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida. url Similar a uma string , mas contendo uma URL v\u00e1lida. hex Similar a uma string , mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes. uuid Similar a uma string , mas contendo um UUID v\u00e1lido. email Similar a uma string , mas contendo um email v\u00e1lido. xml Similar a uma string , mas contendo um XML v\u00e1lido. html Similar a uma string , mas contendo um HTML v\u00e1lido. cpf Similar a uma string , mas contendo um CPF v\u00e1lido. cnpj Similar a uma string , mas contendo um CNPJ v\u00e1lido.","title":"Tipos primitivos"},{"location":"descrevendo-api/#modificadores-de-tipo","text":"O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: ? e [] . Todos os tipos s\u00e3o por padr\u00e3o requeridos, com null n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com ? . Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que null se torna um valor aceit\u00e1vel. Por exemplo: string? aceita qualquer texto livre ou null . O modificador [] pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array , na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: cpf[] denota uma lista de CPF's v\u00e1lidos. Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: int[]? significa ou null ou uma lista de int 's. string[][] significa uma lista de listas de string 's. bool?[] significa uma lista de ou true ou false ou null .","title":"Modificadores de tipo"},{"location":"descrevendo-api/#tipos-compostos","text":"Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo: { name: string age: uint } Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo optionais, listas ou outros objetos. Por exemplo: { id: uuid name: string avatar: url? friends: { id: uuid name: string }[] }","title":"Tipos compostos"},{"location":"descrevendo-api/#enum","text":"Em adi\u00e7\u00e3o aos tipos anteriores um enum representa um conjunto limitado de possibilidades de valores. Por padr\u00e3o os","title":"Enum"},{"location":"primeiro-projeto/","text":"Primeiro projeto (em Node.js) Servidor Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript parece ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias. Cliente","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#primeiro-projeto-em-nodejs","text":"","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#servidor","text":"Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript parece ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias.","title":"Servidor"},{"location":"primeiro-projeto/#cliente","text":"","title":"Cliente"}]}