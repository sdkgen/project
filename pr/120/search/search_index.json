{"config":{"lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conhecendo o sdkgen \u00b6 O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas em recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada sdkgen . Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados. Recursos \u00b6 Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha. Caracter\u00edsticas \u00b6 O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma ass\u00edncrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Conhecendo o sdkgen"},{"location":"#conhecendo-o-sdkgen","text":"O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas em recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada sdkgen . Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados.","title":"Conhecendo o sdkgen"},{"location":"#recursos","text":"Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha.","title":"Recursos"},{"location":"#caracteristicas","text":"O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma ass\u00edncrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Caracter\u00edsticas"},{"location":"descrevendo-api/","text":"Descrevendo uma API \u00b6 API's do sdkgen s\u00e3o descritas em um arquivo .sdkgen . O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o. Tipos \u00b6 O primeiro passo para o entendimento de uma descri\u00e7\u00e3o de API do sdkgen \u00e9 compreender a gram\u00e1tica de tipos. Tipos primitivos \u00b6 O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas. Tipo Descri\u00e7\u00e3o string Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8. int Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647. uint Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295. bigint Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso. float Um n\u00famero de ponto flutuante de 64 bits, similar ao double do C. money Um n\u00famero inteiro com precis\u00e3o estendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras bool Ou true ou false . json Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora null possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser null diretamente. Para isso utilize json? . date Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize datetime . datetime Representa um instante no tempo com precis\u00e3o de milissegundos. Este instante ser\u00e1 sempre traduzido para o fuso hor\u00e1rio local do recebedor da mensagem. bytes Uma sequ\u00eancia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios. base64 Similar a uma string , mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida. url Similar a uma string , mas contendo uma URL v\u00e1lida. hex Similar a uma string , mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes. uuid Similar a uma string , mas contendo um UUID v\u00e1lido. email Similar a uma string , mas contendo um e-mail v\u00e1lido. xml Similar a uma string , mas contendo um XML v\u00e1lido. html Similar a uma string , mas contendo um HTML v\u00e1lido. cpf Similar a uma string , mas contendo um CPF v\u00e1lido. cnpj Similar a uma string , mas contendo um CNPJ v\u00e1lido. Modificadores de tipo \u00b6 O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: ? e [] . Todos os tipos s\u00e3o por padr\u00e3o requeridos, com null n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com ? . Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que null se torna um valor aceit\u00e1vel. Por exemplo: string? aceita qualquer texto livre ou null . O modificador [] pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array , na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: cpf[] denota uma lista de CPF's v\u00e1lidos. Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: int[]? significa ou null ou uma lista de int 's. string[][] significa uma lista de listas de string 's. bool?[] significa uma lista de ou true ou false ou null . Tipos compostos \u00b6 Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo: { name: string age: uint } Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo opcionais, listas ou outros objetos. Por exemplo: { id: uuid name: string avatar: url? friends: { id: uuid name: string }[] } Enum \u00b6 Em adi\u00e7\u00e3o aos tipos anteriores um enum representa um conjunto limitado de possibilidades de valores, similar as enumera\u00e7\u00f5es em outras linguagens. A sintaxe inicia com a palavra chave enum , seguida por uma sequ\u00eancia de palavras entre chaves, separadas por espa\u00e7os ou quebras de linha. Por exemplo: enum { sent received failed } Ou: enum { small medium large } Enums podem aparecer em qualquer posi\u00e7\u00e3o que um tipo pode, inclusive sendo opcional, lista ou parte de um tipo composto. Por exemplo: { name: string skills: enum { javascript csharp go }[] } Estrutura de um arquivo .sdkgen . \u00b6 Em um arquivo .sdkgen voc\u00ea pode definir fun\u00e7\u00f5es, tipos nomeados e erros. Tipos nomeados \u00b6 Tipos nomeados podem ser criados com a sintaxe type NomeDoTipo Tipo . Por exemplo: type PersonName string Embora qualquer um dos tipos descritos acima possa aparece na defini\u00e7\u00e3o de um tipo nomeado, esta constru\u00e7\u00e3o \u00e9 muito mais comum com tipos compostos e enums. Por exemplo: type Person { name: string age: uint } Uma vez que um tipo nomeado tenha sido definido, o nome do tipo pode ser utilizado em qualquer lugar que receba um tipo. Por exemplo: type UserType enum { guest fullUser admin } type User { id: uuid type: UserType name: string } Dessa maneira tipos podem ser combinados e utilizados m\u00faltiplas vezes sem repeti\u00e7\u00e3o. Um mesmo nome pode ser declarado mais de uma vez, desde que todas as declara\u00e7\u00f5es sejam id\u00eanticas. A ordem das declara\u00e7\u00f5es n\u00e3o tem import\u00e2ncia (a declara\u00e7\u00e3o do tipo pode aparecer depois do seu uso). Tipos, no entanto, n\u00e3o podem ser recursivos. Fun\u00e7\u00f5es \u00b6 A descri\u00e7\u00e3o das fun\u00e7\u00f5es \u00e9 provavelmente a parte mais importante da sua API. Toda fun\u00e7\u00e3o possui um nome, uma lista de argumentos e opcionalmente um tipo de retorno. Todas as fun\u00e7\u00f5es descritas estar\u00e3o expostas para serem chamadas por seus usu\u00e1rios, cabendo \u00e0 implementa\u00e7\u00e3o de sua API o trabalho de autenticar e autorizar acessos. Cada fun\u00e7\u00e3o deve possuir um nome claro que indique seu funcionamento, geralmente iniciando com um verbo. Exemplo da sintaxe: fn addNumbers(first: int, second: int): int Argumentos podem vir em qualquer quantidade e todos os tipos devem ser obrigatoriamente especificados. Caso um argumento seja opcional, utilize o modificador de tipo opcional ? ao fim do tipo. O retorno da fun\u00e7\u00e3o pode ou n\u00e3o ser especificado. Caso n\u00e3o seja, a fun\u00e7\u00e3o n\u00e3o retornar\u00e1 nenhum valor. Todas as fun\u00e7\u00f5es descritas ser\u00e3o expostas nos c\u00f3digos gerados pelo sdkgen para cliente ou para servidor, na forma de fun\u00e7\u00f5es que retornam Promise , Future ou equivalente. O nome de cada fun\u00e7\u00e3o deve ser \u00fanico, n\u00e3o havendo suporte a sobrecarga de fun\u00e7\u00f5es (ou seja, n\u00e3o \u00e9 poss\u00edvel diferenciar duas fun\u00e7\u00f5es apenas pelo tipo de seus argumentos). Erros \u00b6 Toda API possui erros mapeados, seja por conta de um argumento passado incorretamente, por um recurso solicitado n\u00e3o existir ou por uma falha de um servi\u00e7o externo, por exemplo. \u00c9 importante que esses erros poss\u00edveis sejam tamb\u00e9m descritos para que um cliente n\u00e3o seja surpreendido. No sdkgen voc\u00ea pode declarar errors com a nota\u00e7\u00e3o error NomeDoErro . Por exemplo: error InvalidArgument error NotFound A implementa\u00e7\u00e3o do servidor poder\u00e1 lan\u00e7ar esses erros ao longo da execu\u00e7\u00e3o e estes ser\u00e3o transmitidos ao cliente junto a uma mensagem de texto livre, de forma que o cliente possa tratar. Toda API sdkgen possui um erro impl\u00edcito de nome Fatal . Qualquer erro que seja lan\u00e7ado no servidor que n\u00e3o seja um dos erros descritos no contrato da API ser\u00e1 convertido em um erro de tipo Fatal antes de ser encaminhado ao cliente. Idealmente uma API nunca deve deixar escapar um erro Fatal . Importando outros arquivos \u00b6 Conforme uma API se torna maior e mais complexa passa a ser interessante dividir em m\u00faltiplos arquivos. Para isso a palavra chave import pode ser utilizada. Por exemplo: import \"../user\" O significado desta linha \u00e9 buscar um arquivo chamado ../user.sdkgen a partir da pasta atual. O .. neste caso significa \"a pasta acima da pasta atual\". Qualquer caminho relativo ao arquivo atual pode ser passado e a extens\u00e3o do arquivo ( .sdkgen ) n\u00e3o deve ser mencionada. O comportamento \u00e9 diretamente equivalente a copiar o conte\u00fado do arquivo e colar dentro do arquivo atual, na posi\u00e7\u00e3o do import. Cuidado para n\u00e3o incluir o mesmo arquivo mais de uma vez. Composi\u00e7\u00e3o de tipos \u00b6 Tipos podem ser criados a partir de outros tipos j\u00e1 existentes. Atualmente o sdkgen suporta apenas um operador neste sentido, o spread. Spreads \u00b6 Ao expressar um tipo composto (estrutura com um ou mais campos), voc\u00ea pode copiar os campos de outro tipo j\u00e1 existente no local. Para isso utilize ...NomeDoTipo dentro da defini\u00e7\u00e3o de uma estrutura, junto com os demais campos. Por exemplo: type BasicUser { id: uuid name: string } type User { email: string ...BasicUser friends: BasicUser[] } Neste exemplo o tipo User ter\u00e1 4 campos: email , id , name e friends . O operador ... far\u00e1 papel de copiar os campos de BasicUser para User . \u00c9 exatamente equivalente a escrever: type BasicUser { id: uuid name: string } type User { email: string id: uuid name: string friends: BasicUser[] } Um tipo pode conter m\u00faltiplos spreads. Caso um campo exista tanto no tipo atual quanto vindo do spread, o campo vindo do spread ser\u00e1 utilizado. Caso um mesmo campo apare\u00e7a em mais de um spread, a \u00faltima ocorr\u00eancia prevalecer\u00e1. Note que isso significa que um spread sempre substitui o campo do tipo, em caso de conflito. Exemplo: type A { foo: int } type B { foo: string } type C { bar: int } type Test1 { ...B ...A } type Test2 { ...C bar: string } Neste exemplo Test1 ter\u00e1 um campo foo de tipo int , j\u00e1 que ...A aparece por \u00faltimo. Test2 , por sua vez, ter\u00e1 um campo bar de tipo int , j\u00e1 que spreads sempre tem prioridade a campos locais. Exemplo final \u00b6 error NotFound type User { id: uuid avatar: url? name: string type: enum { guest fullUser admin } } fn getUser(id: uuid): User","title":"Descrevendo uma API"},{"location":"descrevendo-api/#descrevendo-uma-api","text":"API's do sdkgen s\u00e3o descritas em um arquivo .sdkgen . O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o.","title":"Descrevendo uma API"},{"location":"descrevendo-api/#tipos","text":"O primeiro passo para o entendimento de uma descri\u00e7\u00e3o de API do sdkgen \u00e9 compreender a gram\u00e1tica de tipos.","title":"Tipos"},{"location":"descrevendo-api/#tipos-primitivos","text":"O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas. Tipo Descri\u00e7\u00e3o string Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8. int Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647. uint Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295. bigint Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso. float Um n\u00famero de ponto flutuante de 64 bits, similar ao double do C. money Um n\u00famero inteiro com precis\u00e3o estendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras bool Ou true ou false . json Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora null possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser null diretamente. Para isso utilize json? . date Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize datetime . datetime Representa um instante no tempo com precis\u00e3o de milissegundos. Este instante ser\u00e1 sempre traduzido para o fuso hor\u00e1rio local do recebedor da mensagem. bytes Uma sequ\u00eancia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios. base64 Similar a uma string , mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida. url Similar a uma string , mas contendo uma URL v\u00e1lida. hex Similar a uma string , mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes. uuid Similar a uma string , mas contendo um UUID v\u00e1lido. email Similar a uma string , mas contendo um e-mail v\u00e1lido. xml Similar a uma string , mas contendo um XML v\u00e1lido. html Similar a uma string , mas contendo um HTML v\u00e1lido. cpf Similar a uma string , mas contendo um CPF v\u00e1lido. cnpj Similar a uma string , mas contendo um CNPJ v\u00e1lido.","title":"Tipos primitivos"},{"location":"descrevendo-api/#modificadores-de-tipo","text":"O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: ? e [] . Todos os tipos s\u00e3o por padr\u00e3o requeridos, com null n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com ? . Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que null se torna um valor aceit\u00e1vel. Por exemplo: string? aceita qualquer texto livre ou null . O modificador [] pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array , na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: cpf[] denota uma lista de CPF's v\u00e1lidos. Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: int[]? significa ou null ou uma lista de int 's. string[][] significa uma lista de listas de string 's. bool?[] significa uma lista de ou true ou false ou null .","title":"Modificadores de tipo"},{"location":"descrevendo-api/#tipos-compostos","text":"Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo: { name: string age: uint } Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo opcionais, listas ou outros objetos. Por exemplo: { id: uuid name: string avatar: url? friends: { id: uuid name: string }[] }","title":"Tipos compostos"},{"location":"descrevendo-api/#enum","text":"Em adi\u00e7\u00e3o aos tipos anteriores um enum representa um conjunto limitado de possibilidades de valores, similar as enumera\u00e7\u00f5es em outras linguagens. A sintaxe inicia com a palavra chave enum , seguida por uma sequ\u00eancia de palavras entre chaves, separadas por espa\u00e7os ou quebras de linha. Por exemplo: enum { sent received failed } Ou: enum { small medium large } Enums podem aparecer em qualquer posi\u00e7\u00e3o que um tipo pode, inclusive sendo opcional, lista ou parte de um tipo composto. Por exemplo: { name: string skills: enum { javascript csharp go }[] }","title":"Enum"},{"location":"descrevendo-api/#estrutura-de-um-arquivo-sdkgen","text":"Em um arquivo .sdkgen voc\u00ea pode definir fun\u00e7\u00f5es, tipos nomeados e erros.","title":"Estrutura de um arquivo .sdkgen."},{"location":"descrevendo-api/#tipos-nomeados","text":"Tipos nomeados podem ser criados com a sintaxe type NomeDoTipo Tipo . Por exemplo: type PersonName string Embora qualquer um dos tipos descritos acima possa aparece na defini\u00e7\u00e3o de um tipo nomeado, esta constru\u00e7\u00e3o \u00e9 muito mais comum com tipos compostos e enums. Por exemplo: type Person { name: string age: uint } Uma vez que um tipo nomeado tenha sido definido, o nome do tipo pode ser utilizado em qualquer lugar que receba um tipo. Por exemplo: type UserType enum { guest fullUser admin } type User { id: uuid type: UserType name: string } Dessa maneira tipos podem ser combinados e utilizados m\u00faltiplas vezes sem repeti\u00e7\u00e3o. Um mesmo nome pode ser declarado mais de uma vez, desde que todas as declara\u00e7\u00f5es sejam id\u00eanticas. A ordem das declara\u00e7\u00f5es n\u00e3o tem import\u00e2ncia (a declara\u00e7\u00e3o do tipo pode aparecer depois do seu uso). Tipos, no entanto, n\u00e3o podem ser recursivos.","title":"Tipos nomeados"},{"location":"descrevendo-api/#funcoes","text":"A descri\u00e7\u00e3o das fun\u00e7\u00f5es \u00e9 provavelmente a parte mais importante da sua API. Toda fun\u00e7\u00e3o possui um nome, uma lista de argumentos e opcionalmente um tipo de retorno. Todas as fun\u00e7\u00f5es descritas estar\u00e3o expostas para serem chamadas por seus usu\u00e1rios, cabendo \u00e0 implementa\u00e7\u00e3o de sua API o trabalho de autenticar e autorizar acessos. Cada fun\u00e7\u00e3o deve possuir um nome claro que indique seu funcionamento, geralmente iniciando com um verbo. Exemplo da sintaxe: fn addNumbers(first: int, second: int): int Argumentos podem vir em qualquer quantidade e todos os tipos devem ser obrigatoriamente especificados. Caso um argumento seja opcional, utilize o modificador de tipo opcional ? ao fim do tipo. O retorno da fun\u00e7\u00e3o pode ou n\u00e3o ser especificado. Caso n\u00e3o seja, a fun\u00e7\u00e3o n\u00e3o retornar\u00e1 nenhum valor. Todas as fun\u00e7\u00f5es descritas ser\u00e3o expostas nos c\u00f3digos gerados pelo sdkgen para cliente ou para servidor, na forma de fun\u00e7\u00f5es que retornam Promise , Future ou equivalente. O nome de cada fun\u00e7\u00e3o deve ser \u00fanico, n\u00e3o havendo suporte a sobrecarga de fun\u00e7\u00f5es (ou seja, n\u00e3o \u00e9 poss\u00edvel diferenciar duas fun\u00e7\u00f5es apenas pelo tipo de seus argumentos).","title":"Fun\u00e7\u00f5es"},{"location":"descrevendo-api/#erros","text":"Toda API possui erros mapeados, seja por conta de um argumento passado incorretamente, por um recurso solicitado n\u00e3o existir ou por uma falha de um servi\u00e7o externo, por exemplo. \u00c9 importante que esses erros poss\u00edveis sejam tamb\u00e9m descritos para que um cliente n\u00e3o seja surpreendido. No sdkgen voc\u00ea pode declarar errors com a nota\u00e7\u00e3o error NomeDoErro . Por exemplo: error InvalidArgument error NotFound A implementa\u00e7\u00e3o do servidor poder\u00e1 lan\u00e7ar esses erros ao longo da execu\u00e7\u00e3o e estes ser\u00e3o transmitidos ao cliente junto a uma mensagem de texto livre, de forma que o cliente possa tratar. Toda API sdkgen possui um erro impl\u00edcito de nome Fatal . Qualquer erro que seja lan\u00e7ado no servidor que n\u00e3o seja um dos erros descritos no contrato da API ser\u00e1 convertido em um erro de tipo Fatal antes de ser encaminhado ao cliente. Idealmente uma API nunca deve deixar escapar um erro Fatal .","title":"Erros"},{"location":"descrevendo-api/#importando-outros-arquivos","text":"Conforme uma API se torna maior e mais complexa passa a ser interessante dividir em m\u00faltiplos arquivos. Para isso a palavra chave import pode ser utilizada. Por exemplo: import \"../user\" O significado desta linha \u00e9 buscar um arquivo chamado ../user.sdkgen a partir da pasta atual. O .. neste caso significa \"a pasta acima da pasta atual\". Qualquer caminho relativo ao arquivo atual pode ser passado e a extens\u00e3o do arquivo ( .sdkgen ) n\u00e3o deve ser mencionada. O comportamento \u00e9 diretamente equivalente a copiar o conte\u00fado do arquivo e colar dentro do arquivo atual, na posi\u00e7\u00e3o do import. Cuidado para n\u00e3o incluir o mesmo arquivo mais de uma vez.","title":"Importando outros arquivos"},{"location":"descrevendo-api/#composicao-de-tipos","text":"Tipos podem ser criados a partir de outros tipos j\u00e1 existentes. Atualmente o sdkgen suporta apenas um operador neste sentido, o spread.","title":"Composi\u00e7\u00e3o de tipos"},{"location":"descrevendo-api/#spreads","text":"Ao expressar um tipo composto (estrutura com um ou mais campos), voc\u00ea pode copiar os campos de outro tipo j\u00e1 existente no local. Para isso utilize ...NomeDoTipo dentro da defini\u00e7\u00e3o de uma estrutura, junto com os demais campos. Por exemplo: type BasicUser { id: uuid name: string } type User { email: string ...BasicUser friends: BasicUser[] } Neste exemplo o tipo User ter\u00e1 4 campos: email , id , name e friends . O operador ... far\u00e1 papel de copiar os campos de BasicUser para User . \u00c9 exatamente equivalente a escrever: type BasicUser { id: uuid name: string } type User { email: string id: uuid name: string friends: BasicUser[] } Um tipo pode conter m\u00faltiplos spreads. Caso um campo exista tanto no tipo atual quanto vindo do spread, o campo vindo do spread ser\u00e1 utilizado. Caso um mesmo campo apare\u00e7a em mais de um spread, a \u00faltima ocorr\u00eancia prevalecer\u00e1. Note que isso significa que um spread sempre substitui o campo do tipo, em caso de conflito. Exemplo: type A { foo: int } type B { foo: string } type C { bar: int } type Test1 { ...B ...A } type Test2 { ...C bar: string } Neste exemplo Test1 ter\u00e1 um campo foo de tipo int , j\u00e1 que ...A aparece por \u00faltimo. Test2 , por sua vez, ter\u00e1 um campo bar de tipo int , j\u00e1 que spreads sempre tem prioridade a campos locais.","title":"Spreads"},{"location":"descrevendo-api/#exemplo-final","text":"error NotFound type User { id: uuid avatar: url? name: string type: enum { guest fullUser admin } } fn getUser(id: uuid): User","title":"Exemplo final"},{"location":"faq/","text":"Problemas comuns \u00b6 TypeError: Class constructor BaseApiConfig cannot be invoked without 'new' \u00b6 O target para TypeScript em Node \u00e9 previamente compilado e distribu\u00eddo para ES2017, que j\u00e1 \u00e9 suportado por todas as vers\u00f5es n\u00e3o depreciadas do Node. No entanto o TypeScript por padr\u00e3o cria projetos para ES5, vers\u00e3o que somente \u00e9 \u00fatil quando visando browsers antigos como o Internet Explorer. A corre\u00e7\u00e3o mais simples \u00e9 modificar o tsconfig.json do seu projeto para uma vers\u00e3o do JavaScript igual ou maior que ES2017.","title":"Problemas comuns"},{"location":"faq/#problemas-comuns","text":"","title":"Problemas comuns"},{"location":"faq/#typeerror-class-constructor-baseapiconfig-cannot-be-invoked-without-new","text":"O target para TypeScript em Node \u00e9 previamente compilado e distribu\u00eddo para ES2017, que j\u00e1 \u00e9 suportado por todas as vers\u00f5es n\u00e3o depreciadas do Node. No entanto o TypeScript por padr\u00e3o cria projetos para ES5, vers\u00e3o que somente \u00e9 \u00fatil quando visando browsers antigos como o Internet Explorer. A corre\u00e7\u00e3o mais simples \u00e9 modificar o tsconfig.json do seu projeto para uma vers\u00e3o do JavaScript igual ou maior que ES2017.","title":"TypeError: Class constructor BaseApiConfig cannot be invoked without 'new'"},{"location":"primeiro-projeto/","text":"Primeiro projeto (em Node.js) \u00b6 Servidor \u00b6 Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript parece ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias. Cliente \u00b6","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#primeiro-projeto-em-nodejs","text":"","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#servidor","text":"Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript parece ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias.","title":"Servidor"},{"location":"primeiro-projeto/#cliente","text":"","title":"Cliente"},{"location":"aprofundando/datas/","text":"Comportamento de date e datetime \u00b6 Como descrito na sess\u00e3o sobre tipos primitivos , date e datetime possuem significados parecidos, mas fundamentalmente diferentes. Utilize datetime quando quer se referir a um ponto no tempo utilize date quando quer se referir a uma data no calend\u00e1rio. Ponto no tempo: datetime \u00b6 Um ponto instant\u00e2neo no tempo deve ser o mesmo instante para todos os observadores, independente de onde eles est\u00e3o. Por conta disso o sdkgen sempre ir\u00e1 corrigir as varia\u00e7\u00f5es de timezone dos datetime s trocados entre as duas partes. Dessa forma uma das partes pode falar sobre um instante no tempo em seu fuso hor\u00e1rio local e o outro lado ir\u00e1 receber exatamente o mesmo instante, mas convertido no seu fuso hor\u00e1rio pr\u00f3prio. Esse comportamento \u00e9 conveniente ao trocar a informa\u00e7\u00e3o da data de publica\u00e7\u00e3o de uma postagem, por exemplo. Note que o \"inicio do dia\" e o \"fim do dia\" s\u00e3o momentos diferentes em fusos hor\u00e1rios diferentes. Data no calend\u00e1rio: date \u00b6 Um dia espec\u00edfico no calend\u00e1rio \u00e9 o mesmo em todo o globo, embora represente um intervalo de tempo diferente em cada fuso hor\u00e1rio. Datas ser\u00e3o passadas pelo sdkgen sem nenhuma altera\u00e7\u00e3o. Esse tipo \u00e9 \u00fatil para se referir a um feriado, ou a um intervalo de datas em um relat\u00f3rio financeiro. Como a maioria das linguagens n\u00e3o possui um tipo nativo para uma data, o mesmo tipo que datetime ser\u00e1 utilizado. O tempo ser\u00e1 recebido como se fosse o in\u00edcio do dia na sua timezone local. Lembre-se de tratar antes de utilizar. Por exemplo, caso esteja fazendo um filtro de datas, considere trocar a data final para \"fim do dia\" ou somar mais um dia, de forma que o intervalo seja inclusivo.","title":"date e datetime"},{"location":"aprofundando/datas/#comportamento-de-date-e-datetime","text":"Como descrito na sess\u00e3o sobre tipos primitivos , date e datetime possuem significados parecidos, mas fundamentalmente diferentes. Utilize datetime quando quer se referir a um ponto no tempo utilize date quando quer se referir a uma data no calend\u00e1rio.","title":"Comportamento de date e datetime"},{"location":"aprofundando/datas/#ponto-no-tempo-datetime","text":"Um ponto instant\u00e2neo no tempo deve ser o mesmo instante para todos os observadores, independente de onde eles est\u00e3o. Por conta disso o sdkgen sempre ir\u00e1 corrigir as varia\u00e7\u00f5es de timezone dos datetime s trocados entre as duas partes. Dessa forma uma das partes pode falar sobre um instante no tempo em seu fuso hor\u00e1rio local e o outro lado ir\u00e1 receber exatamente o mesmo instante, mas convertido no seu fuso hor\u00e1rio pr\u00f3prio. Esse comportamento \u00e9 conveniente ao trocar a informa\u00e7\u00e3o da data de publica\u00e7\u00e3o de uma postagem, por exemplo. Note que o \"inicio do dia\" e o \"fim do dia\" s\u00e3o momentos diferentes em fusos hor\u00e1rios diferentes.","title":"Ponto no tempo: datetime"},{"location":"aprofundando/datas/#data-no-calendario-date","text":"Um dia espec\u00edfico no calend\u00e1rio \u00e9 o mesmo em todo o globo, embora represente um intervalo de tempo diferente em cada fuso hor\u00e1rio. Datas ser\u00e3o passadas pelo sdkgen sem nenhuma altera\u00e7\u00e3o. Esse tipo \u00e9 \u00fatil para se referir a um feriado, ou a um intervalo de datas em um relat\u00f3rio financeiro. Como a maioria das linguagens n\u00e3o possui um tipo nativo para uma data, o mesmo tipo que datetime ser\u00e1 utilizado. O tempo ser\u00e1 recebido como se fosse o in\u00edcio do dia na sua timezone local. Lembre-se de tratar antes de utilizar. Por exemplo, caso esteja fazendo um filtro de datas, considere trocar a data final para \"fim do dia\" ou somar mais um dia, de forma que o intervalo seja inclusivo.","title":"Data no calend\u00e1rio: date"}]}