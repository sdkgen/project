{"config":{"lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conhecendo o sdkgen O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada \"sdkgen\". Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados. Recursos Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha. Caracter\u00edsticas O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma assincrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Conhecendo o sdkgen"},{"location":"#conhecendo-o-sdkgen","text":"O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada \"sdkgen\". Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados.","title":"Conhecendo o sdkgen"},{"location":"#recursos","text":"Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha.","title":"Recursos"},{"location":"#caracteristicas","text":"O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma assincrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Caracter\u00edsticas"},{"location":"primeiro-projeto/","text":"Primeiro projeto (em Node.js) Servidor Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript parece ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias. Cliente","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#primeiro-projeto-em-nodejs","text":"","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#servidor","text":"Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript parece ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias.","title":"Servidor"},{"location":"primeiro-projeto/#cliente","text":"","title":"Cliente"}]}