{"config":{"lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conhecendo o sdkgen \u00b6 O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas em recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada sdkgen . Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados. Recursos \u00b6 Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha. Caracter\u00edsticas \u00b6 O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma ass\u00edncrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Conhecendo o sdkgen"},{"location":"#conhecendo-o-sdkgen","text":"O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas em recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada sdkgen . Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados.","title":"Conhecendo o sdkgen"},{"location":"#recursos","text":"Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte. Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core. Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter. Um playground interativo para explorar e realizar chamadas. Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha.","title":"Recursos"},{"location":"#caracteristicas","text":"O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto. A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo: type User { id: uuid email: string name: string } fn login(email: string, password: string): User fn logout() fn me(): User Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como string e uuid ), mas voc\u00ea pode definir tipos adicionais como User acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma ass\u00edncrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.","title":"Caracter\u00edsticas"},{"location":"cli/","text":"CLI \u00b6 Instalando \u00b6 Para uma instala\u00e7\u00e3o global utilize: npm i -g @sdkgen/cli Para instalar dentro do seu projeto Node corrente, utilize: npm i --save-dev @sdkgen/cli Neste caso voc\u00ea precisa chamar como npx sdkgen em vez de sdkgen . Gerando c\u00f3digo \u00b6 O uso prim\u00e1rio da CLI \u00e9 gerar c\u00f3digo fonte dos targets, seja de servidor ou de cliente. Para isso utilize a seguinte estrutura de comando: sdkgen <source file> -o <output file> -t <target name> Onde <source file> \u00e9 o seu arquivo .sdkgen , por exemplo src/api.sdkgen . <output file> \u00e9 o arquivo de destino, por exemplo api.dart . Por fim o <target name> se refere ao slug do target a ser utilizado, por exemplo flutter . Compondo este exemplo: sdkgen src/api.sdkgen -o api.dart -t flutter Estes s\u00e3o os target poss\u00edveis: Slug Descri\u00e7\u00e3o csharp_server Servidor .NET Core, em C# flutter Cliente para Flutter, em Dart kotlin_android Cliente para Android nativo, em Kotlin typescript_interfaces Apenas tipos da API, em TypeScript typescript_nodeclient Cliente para Node.js, em TypeScript typescript_nodeserver Servidor Node.js, em TypeScript typescript_web Cliente para uso na Web, em TypeScript Checagem de compatibilidade \u00b6 \u00c9 frequente precisar realizar altera\u00e7\u00f5es em uma API existente, seja adicionando novas fun\u00e7\u00f5es, novos campos, ou removendo itens. Nestes casos \u00e9 sempre preciso ter cuidado para n\u00e3o introduzir uma \"Breaking Change\", ou seja: uma altera\u00e7\u00e3o que seja inesperada pelos clientes existentes. Alguns exemplos de altera\u00e7\u00f5es que podem causar problemas: Remover ou renomear uma fun\u00e7\u00e3o; Adicionar um argumento n\u00e3o nul\u00e1vel; Adicionar um novo valor poss\u00edvel em um enum que \u00e9 retornado por uma fun\u00e7\u00e3o; Mudar um argumento de string para uuid . E altera\u00e7\u00f5es que podem serem feitas sem risco: Adicionar um novo campo em um objeto que \u00e9 retornado por uma fun\u00e7\u00e3o; Mudar a ordem dos argumentos de uma fun\u00e7\u00e3o; Adicionar novas fun\u00e7\u00f5es; Mudar um argumento de uuid para string . Estas regras podem rapidamente ficar complexas e s\u00e3o dif\u00edceis de checar por quem est\u00e1 escrevendo uma altera\u00e7\u00e3o em uma API existente. Por conta disso o sdkgen vem com uma ferramenta para checar compatibilidade entre altera\u00e7\u00f5es. Para isso utilize o seguinte comando: sdkgen compatibility --old <old source file> --new <new source file> Por exemplo: sdkgen compatibility --old api_antiga.sdkgen --new api_nova.sdkgen Caso existam quebras de compatibilidade estas ser\u00e3o reportadas.","title":"CLI"},{"location":"cli/#cli","text":"","title":"CLI"},{"location":"cli/#instalando","text":"Para uma instala\u00e7\u00e3o global utilize: npm i -g @sdkgen/cli Para instalar dentro do seu projeto Node corrente, utilize: npm i --save-dev @sdkgen/cli Neste caso voc\u00ea precisa chamar como npx sdkgen em vez de sdkgen .","title":"Instalando"},{"location":"cli/#gerando-codigo","text":"O uso prim\u00e1rio da CLI \u00e9 gerar c\u00f3digo fonte dos targets, seja de servidor ou de cliente. Para isso utilize a seguinte estrutura de comando: sdkgen <source file> -o <output file> -t <target name> Onde <source file> \u00e9 o seu arquivo .sdkgen , por exemplo src/api.sdkgen . <output file> \u00e9 o arquivo de destino, por exemplo api.dart . Por fim o <target name> se refere ao slug do target a ser utilizado, por exemplo flutter . Compondo este exemplo: sdkgen src/api.sdkgen -o api.dart -t flutter Estes s\u00e3o os target poss\u00edveis: Slug Descri\u00e7\u00e3o csharp_server Servidor .NET Core, em C# flutter Cliente para Flutter, em Dart kotlin_android Cliente para Android nativo, em Kotlin typescript_interfaces Apenas tipos da API, em TypeScript typescript_nodeclient Cliente para Node.js, em TypeScript typescript_nodeserver Servidor Node.js, em TypeScript typescript_web Cliente para uso na Web, em TypeScript","title":"Gerando c\u00f3digo"},{"location":"cli/#checagem-de-compatibilidade","text":"\u00c9 frequente precisar realizar altera\u00e7\u00f5es em uma API existente, seja adicionando novas fun\u00e7\u00f5es, novos campos, ou removendo itens. Nestes casos \u00e9 sempre preciso ter cuidado para n\u00e3o introduzir uma \"Breaking Change\", ou seja: uma altera\u00e7\u00e3o que seja inesperada pelos clientes existentes. Alguns exemplos de altera\u00e7\u00f5es que podem causar problemas: Remover ou renomear uma fun\u00e7\u00e3o; Adicionar um argumento n\u00e3o nul\u00e1vel; Adicionar um novo valor poss\u00edvel em um enum que \u00e9 retornado por uma fun\u00e7\u00e3o; Mudar um argumento de string para uuid . E altera\u00e7\u00f5es que podem serem feitas sem risco: Adicionar um novo campo em um objeto que \u00e9 retornado por uma fun\u00e7\u00e3o; Mudar a ordem dos argumentos de uma fun\u00e7\u00e3o; Adicionar novas fun\u00e7\u00f5es; Mudar um argumento de uuid para string . Estas regras podem rapidamente ficar complexas e s\u00e3o dif\u00edceis de checar por quem est\u00e1 escrevendo uma altera\u00e7\u00e3o em uma API existente. Por conta disso o sdkgen vem com uma ferramenta para checar compatibilidade entre altera\u00e7\u00f5es. Para isso utilize o seguinte comando: sdkgen compatibility --old <old source file> --new <new source file> Por exemplo: sdkgen compatibility --old api_antiga.sdkgen --new api_nova.sdkgen Caso existam quebras de compatibilidade estas ser\u00e3o reportadas.","title":"Checagem de compatibilidade"},{"location":"descrevendo-api/","text":"Descrevendo uma API \u00b6 API's do sdkgen s\u00e3o descritas em um arquivo .sdkgen . O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o. Tipos \u00b6 O primeiro passo para o entendimento de uma descri\u00e7\u00e3o de API do sdkgen \u00e9 compreender a gram\u00e1tica de tipos. Tipos primitivos \u00b6 O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas. Tipo Descri\u00e7\u00e3o string Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8. int Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647. uint Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295. bigint Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso. float Um n\u00famero de ponto flutuante de 64 bits, similar ao double do C. money Um n\u00famero inteiro com precis\u00e3o estendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras bool Ou true ou false . json Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora null possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser null diretamente. Para isso utilize json? . date Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize datetime . datetime Representa um instante no tempo com precis\u00e3o de milissegundos. Este instante ser\u00e1 sempre traduzido para o fuso hor\u00e1rio local do recebedor da mensagem. bytes Uma sequ\u00eancia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios. base64 Similar a uma string , mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida. url Similar a uma string , mas contendo uma URL v\u00e1lida. hex Similar a uma string , mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes. uuid Similar a uma string , mas contendo um UUID v\u00e1lido. email Similar a uma string , mas contendo um e-mail v\u00e1lido. xml Similar a uma string , mas contendo um XML v\u00e1lido. html Similar a uma string , mas contendo um HTML v\u00e1lido. cpf Similar a uma string , mas contendo um CPF v\u00e1lido. cnpj Similar a uma string , mas contendo um CNPJ v\u00e1lido. Modificadores de tipo \u00b6 O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: ? e [] . Todos os tipos s\u00e3o por padr\u00e3o requeridos, com null n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com ? . Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que null se torna um valor aceit\u00e1vel. Por exemplo: string? aceita qualquer texto livre ou null . O modificador [] pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array , na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: cpf[] denota uma lista de CPF's v\u00e1lidos. Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: int[]? significa ou null ou uma lista de int 's. string[][] significa uma lista de listas de string 's. bool?[] significa uma lista de ou true ou false ou null . Tipos compostos \u00b6 Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo: { name: string age: uint } Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo opcionais, listas ou outros objetos. Por exemplo: { id: uuid name: string avatar: url? friends: { id: uuid name: string }[] } Enum \u00b6 Em adi\u00e7\u00e3o aos tipos anteriores um enum representa um conjunto limitado de possibilidades de valores, similar as enumera\u00e7\u00f5es em outras linguagens. A sintaxe inicia com a palavra chave enum , seguida por uma sequ\u00eancia de palavras entre chaves, separadas por espa\u00e7os ou quebras de linha. Por exemplo: enum { sent received failed } Ou: enum { small medium large } Enums podem aparecer em qualquer posi\u00e7\u00e3o que um tipo pode, inclusive sendo opcional, lista ou parte de um tipo composto. Por exemplo: { name: string skills: enum { javascript csharp go }[] } Estrutura de um arquivo .sdkgen . \u00b6 Em um arquivo .sdkgen voc\u00ea pode definir fun\u00e7\u00f5es, tipos nomeados e erros. Tipos nomeados \u00b6 Tipos nomeados podem ser criados com a sintaxe type NomeDoTipo Tipo . Por exemplo: type PersonName string Embora qualquer um dos tipos descritos acima possa aparece na defini\u00e7\u00e3o de um tipo nomeado, esta constru\u00e7\u00e3o \u00e9 muito mais comum com tipos compostos e enums. Por exemplo: type Person { name: string age: uint } Uma vez que um tipo nomeado tenha sido definido, o nome do tipo pode ser utilizado em qualquer lugar que receba um tipo. Por exemplo: type UserType enum { guest fullUser admin } type User { id: uuid type: UserType name: string } Dessa maneira tipos podem ser combinados e utilizados m\u00faltiplas vezes sem repeti\u00e7\u00e3o. Um mesmo nome pode ser declarado mais de uma vez, desde que todas as declara\u00e7\u00f5es sejam id\u00eanticas. A ordem das declara\u00e7\u00f5es n\u00e3o tem import\u00e2ncia (a declara\u00e7\u00e3o do tipo pode aparecer depois do seu uso). Tipos, no entanto, n\u00e3o podem ser recursivos. Fun\u00e7\u00f5es \u00b6 A descri\u00e7\u00e3o das fun\u00e7\u00f5es \u00e9 provavelmente a parte mais importante da sua API. Toda fun\u00e7\u00e3o possui um nome, uma lista de argumentos e, opcionalmente, um tipo de retorno. Todas as fun\u00e7\u00f5es descritas estar\u00e3o expostas para serem chamadas por seus usu\u00e1rios, cabendo \u00e0 implementa\u00e7\u00e3o de sua API o trabalho de autenticar e autorizar acessos. Cada fun\u00e7\u00e3o deve possuir um nome claro que indique seu funcionamento, geralmente iniciando com um verbo. Exemplo da sintaxe: fn addNumbers(first: int, second: int): int Argumentos podem vir em qualquer quantidade e todos os tipos devem ser obrigatoriamente especificados. Caso um argumento seja opcional, utilize o modificador de tipo opcional ? ao fim do tipo. O retorno da fun\u00e7\u00e3o pode ou n\u00e3o ser especificado. Caso n\u00e3o seja, a fun\u00e7\u00e3o n\u00e3o retornar\u00e1 nenhum valor. Todas as fun\u00e7\u00f5es descritas ser\u00e3o expostas nos c\u00f3digos gerados pelo sdkgen para cliente ou para servidor, na forma de fun\u00e7\u00f5es que retornam Promise , Future ou equivalente. O nome de cada fun\u00e7\u00e3o deve ser \u00fanico, n\u00e3o havendo suporte a sobrecarga de fun\u00e7\u00f5es (ou seja, n\u00e3o \u00e9 poss\u00edvel diferenciar duas fun\u00e7\u00f5es apenas pelo tipo de seus argumentos). Erros \u00b6 Toda API possui erros mapeados, seja por conta de um argumento passado incorretamente, por um recurso solicitado n\u00e3o existir ou por uma falha de um servi\u00e7o externo, por exemplo. \u00c9 importante que esses erros poss\u00edveis sejam tamb\u00e9m descritos para que um cliente n\u00e3o seja surpreendido. No sdkgen voc\u00ea pode declarar errors com a nota\u00e7\u00e3o error NomeDoErro . Por exemplo: error InvalidArgument error NotFound A implementa\u00e7\u00e3o do servidor poder\u00e1 lan\u00e7ar esses erros ao longo da execu\u00e7\u00e3o e estes ser\u00e3o transmitidos ao cliente junto a uma mensagem de texto livre, de forma que o cliente possa tratar. Toda API sdkgen possui um erro impl\u00edcito de nome Fatal . Qualquer erro que seja lan\u00e7ado no servidor que n\u00e3o seja um dos erros descritos no contrato da API ser\u00e1 convertido em um erro de tipo Fatal antes de ser encaminhado ao cliente. Idealmente uma API nunca deve deixar escapar um erro Fatal . Um erro do sdkgen tamb\u00e9m pode possuir dados adicionais que ajudem a explicar o ocorrido. Esses dados podem ser de qualquer tipo (inclusive objetos) e ser\u00e3o trafegados para o cliente quando o backend lan\u00e7ar o erro. Exemplo: error InvalidArgument { argumentName: string reason: string } error RetryLater datetime Importando outros arquivos \u00b6 Conforme uma API se torna maior e mais complexa passa a ser interessante dividir em m\u00faltiplos arquivos. Para isso a palavra-chave import pode ser utilizada. Por exemplo: import \"../user\" O significado desta linha \u00e9 buscar um arquivo chamado ../user.sdkgen a partir da pasta atual. O .. neste caso significa \"a pasta acima da pasta atual\". Qualquer caminho relativo ao arquivo atual pode ser passado e a extens\u00e3o do arquivo ( .sdkgen ) n\u00e3o deve ser mencionada. O comportamento \u00e9 diretamente equivalente a copiar o conte\u00fado do arquivo e colar dentro do arquivo atual, na posi\u00e7\u00e3o do import. Cuidado para n\u00e3o incluir o mesmo arquivo mais de uma vez. Composi\u00e7\u00e3o de tipos \u00b6 Tipos podem ser criados a partir de outros tipos j\u00e1 existentes. Atualmente o sdkgen suporta apenas um operador neste sentido, o spread. Spreads \u00b6 Ao expressar um tipo composto (estrutura com um ou mais campos), voc\u00ea pode copiar os campos de outro tipo j\u00e1 existente no local. Para isso utilize ...NomeDoTipo dentro da defini\u00e7\u00e3o de uma estrutura, junto com os demais campos. Por exemplo: type BasicUser { id: uuid name: string } type User { email: string ...BasicUser friends: BasicUser[] } Neste exemplo o tipo User ter\u00e1 4 campos: email , id , name e friends . O operador ... far\u00e1 papel de copiar os campos de BasicUser para User . \u00c9 exatamente equivalente a escrever: type BasicUser { id: uuid name: string } type User { email: string id: uuid name: string friends: BasicUser[] } Um tipo pode conter m\u00faltiplos spreads. Caso um campo exista tanto no tipo atual quanto vindo do spread, o campo vindo do spread ser\u00e1 utilizado. Caso um mesmo campo apare\u00e7a em mais de um spread, a \u00faltima ocorr\u00eancia prevalecer\u00e1. Note que isso significa que um spread sempre substitui o campo do tipo, em caso de conflito. Exemplo: type A { foo: int } type B { foo: string } type C { bar: int } type Test1 { ...B ...A } type Test2 { ...C bar: string } Neste exemplo Test1 ter\u00e1 um campo foo de tipo int , j\u00e1 que ...A aparece por \u00faltimo. Test2 , por sua vez, ter\u00e1 um campo bar de tipo int , j\u00e1 que spreads sempre t\u00eam prioridade a campos locais. Exemplo final \u00b6 error NotFound type User { id: uuid avatar: url? name: string type: enum { guest fullUser admin } } fn getUser(id: uuid): User","title":"Descrevendo uma API"},{"location":"descrevendo-api/#descrevendo-uma-api","text":"API's do sdkgen s\u00e3o descritas em um arquivo .sdkgen . O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o.","title":"Descrevendo uma API"},{"location":"descrevendo-api/#tipos","text":"O primeiro passo para o entendimento de uma descri\u00e7\u00e3o de API do sdkgen \u00e9 compreender a gram\u00e1tica de tipos.","title":"Tipos"},{"location":"descrevendo-api/#tipos-primitivos","text":"O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas. Tipo Descri\u00e7\u00e3o string Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8. int Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647. uint Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295. bigint Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso. float Um n\u00famero de ponto flutuante de 64 bits, similar ao double do C. money Um n\u00famero inteiro com precis\u00e3o estendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras bool Ou true ou false . json Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora null possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser null diretamente. Para isso utilize json? . date Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize datetime . datetime Representa um instante no tempo com precis\u00e3o de milissegundos. Este instante ser\u00e1 sempre traduzido para o fuso hor\u00e1rio local do recebedor da mensagem. bytes Uma sequ\u00eancia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios. base64 Similar a uma string , mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida. url Similar a uma string , mas contendo uma URL v\u00e1lida. hex Similar a uma string , mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes. uuid Similar a uma string , mas contendo um UUID v\u00e1lido. email Similar a uma string , mas contendo um e-mail v\u00e1lido. xml Similar a uma string , mas contendo um XML v\u00e1lido. html Similar a uma string , mas contendo um HTML v\u00e1lido. cpf Similar a uma string , mas contendo um CPF v\u00e1lido. cnpj Similar a uma string , mas contendo um CNPJ v\u00e1lido.","title":"Tipos primitivos"},{"location":"descrevendo-api/#modificadores-de-tipo","text":"O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: ? e [] . Todos os tipos s\u00e3o por padr\u00e3o requeridos, com null n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com ? . Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que null se torna um valor aceit\u00e1vel. Por exemplo: string? aceita qualquer texto livre ou null . O modificador [] pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array , na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: cpf[] denota uma lista de CPF's v\u00e1lidos. Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: int[]? significa ou null ou uma lista de int 's. string[][] significa uma lista de listas de string 's. bool?[] significa uma lista de ou true ou false ou null .","title":"Modificadores de tipo"},{"location":"descrevendo-api/#tipos-compostos","text":"Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo: { name: string age: uint } Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo opcionais, listas ou outros objetos. Por exemplo: { id: uuid name: string avatar: url? friends: { id: uuid name: string }[] }","title":"Tipos compostos"},{"location":"descrevendo-api/#enum","text":"Em adi\u00e7\u00e3o aos tipos anteriores um enum representa um conjunto limitado de possibilidades de valores, similar as enumera\u00e7\u00f5es em outras linguagens. A sintaxe inicia com a palavra chave enum , seguida por uma sequ\u00eancia de palavras entre chaves, separadas por espa\u00e7os ou quebras de linha. Por exemplo: enum { sent received failed } Ou: enum { small medium large } Enums podem aparecer em qualquer posi\u00e7\u00e3o que um tipo pode, inclusive sendo opcional, lista ou parte de um tipo composto. Por exemplo: { name: string skills: enum { javascript csharp go }[] }","title":"Enum"},{"location":"descrevendo-api/#estrutura-de-um-arquivo-sdkgen","text":"Em um arquivo .sdkgen voc\u00ea pode definir fun\u00e7\u00f5es, tipos nomeados e erros.","title":"Estrutura de um arquivo .sdkgen."},{"location":"descrevendo-api/#tipos-nomeados","text":"Tipos nomeados podem ser criados com a sintaxe type NomeDoTipo Tipo . Por exemplo: type PersonName string Embora qualquer um dos tipos descritos acima possa aparece na defini\u00e7\u00e3o de um tipo nomeado, esta constru\u00e7\u00e3o \u00e9 muito mais comum com tipos compostos e enums. Por exemplo: type Person { name: string age: uint } Uma vez que um tipo nomeado tenha sido definido, o nome do tipo pode ser utilizado em qualquer lugar que receba um tipo. Por exemplo: type UserType enum { guest fullUser admin } type User { id: uuid type: UserType name: string } Dessa maneira tipos podem ser combinados e utilizados m\u00faltiplas vezes sem repeti\u00e7\u00e3o. Um mesmo nome pode ser declarado mais de uma vez, desde que todas as declara\u00e7\u00f5es sejam id\u00eanticas. A ordem das declara\u00e7\u00f5es n\u00e3o tem import\u00e2ncia (a declara\u00e7\u00e3o do tipo pode aparecer depois do seu uso). Tipos, no entanto, n\u00e3o podem ser recursivos.","title":"Tipos nomeados"},{"location":"descrevendo-api/#funcoes","text":"A descri\u00e7\u00e3o das fun\u00e7\u00f5es \u00e9 provavelmente a parte mais importante da sua API. Toda fun\u00e7\u00e3o possui um nome, uma lista de argumentos e, opcionalmente, um tipo de retorno. Todas as fun\u00e7\u00f5es descritas estar\u00e3o expostas para serem chamadas por seus usu\u00e1rios, cabendo \u00e0 implementa\u00e7\u00e3o de sua API o trabalho de autenticar e autorizar acessos. Cada fun\u00e7\u00e3o deve possuir um nome claro que indique seu funcionamento, geralmente iniciando com um verbo. Exemplo da sintaxe: fn addNumbers(first: int, second: int): int Argumentos podem vir em qualquer quantidade e todos os tipos devem ser obrigatoriamente especificados. Caso um argumento seja opcional, utilize o modificador de tipo opcional ? ao fim do tipo. O retorno da fun\u00e7\u00e3o pode ou n\u00e3o ser especificado. Caso n\u00e3o seja, a fun\u00e7\u00e3o n\u00e3o retornar\u00e1 nenhum valor. Todas as fun\u00e7\u00f5es descritas ser\u00e3o expostas nos c\u00f3digos gerados pelo sdkgen para cliente ou para servidor, na forma de fun\u00e7\u00f5es que retornam Promise , Future ou equivalente. O nome de cada fun\u00e7\u00e3o deve ser \u00fanico, n\u00e3o havendo suporte a sobrecarga de fun\u00e7\u00f5es (ou seja, n\u00e3o \u00e9 poss\u00edvel diferenciar duas fun\u00e7\u00f5es apenas pelo tipo de seus argumentos).","title":"Fun\u00e7\u00f5es"},{"location":"descrevendo-api/#erros","text":"Toda API possui erros mapeados, seja por conta de um argumento passado incorretamente, por um recurso solicitado n\u00e3o existir ou por uma falha de um servi\u00e7o externo, por exemplo. \u00c9 importante que esses erros poss\u00edveis sejam tamb\u00e9m descritos para que um cliente n\u00e3o seja surpreendido. No sdkgen voc\u00ea pode declarar errors com a nota\u00e7\u00e3o error NomeDoErro . Por exemplo: error InvalidArgument error NotFound A implementa\u00e7\u00e3o do servidor poder\u00e1 lan\u00e7ar esses erros ao longo da execu\u00e7\u00e3o e estes ser\u00e3o transmitidos ao cliente junto a uma mensagem de texto livre, de forma que o cliente possa tratar. Toda API sdkgen possui um erro impl\u00edcito de nome Fatal . Qualquer erro que seja lan\u00e7ado no servidor que n\u00e3o seja um dos erros descritos no contrato da API ser\u00e1 convertido em um erro de tipo Fatal antes de ser encaminhado ao cliente. Idealmente uma API nunca deve deixar escapar um erro Fatal . Um erro do sdkgen tamb\u00e9m pode possuir dados adicionais que ajudem a explicar o ocorrido. Esses dados podem ser de qualquer tipo (inclusive objetos) e ser\u00e3o trafegados para o cliente quando o backend lan\u00e7ar o erro. Exemplo: error InvalidArgument { argumentName: string reason: string } error RetryLater datetime","title":"Erros"},{"location":"descrevendo-api/#importando-outros-arquivos","text":"Conforme uma API se torna maior e mais complexa passa a ser interessante dividir em m\u00faltiplos arquivos. Para isso a palavra-chave import pode ser utilizada. Por exemplo: import \"../user\" O significado desta linha \u00e9 buscar um arquivo chamado ../user.sdkgen a partir da pasta atual. O .. neste caso significa \"a pasta acima da pasta atual\". Qualquer caminho relativo ao arquivo atual pode ser passado e a extens\u00e3o do arquivo ( .sdkgen ) n\u00e3o deve ser mencionada. O comportamento \u00e9 diretamente equivalente a copiar o conte\u00fado do arquivo e colar dentro do arquivo atual, na posi\u00e7\u00e3o do import. Cuidado para n\u00e3o incluir o mesmo arquivo mais de uma vez.","title":"Importando outros arquivos"},{"location":"descrevendo-api/#composicao-de-tipos","text":"Tipos podem ser criados a partir de outros tipos j\u00e1 existentes. Atualmente o sdkgen suporta apenas um operador neste sentido, o spread.","title":"Composi\u00e7\u00e3o de tipos"},{"location":"descrevendo-api/#spreads","text":"Ao expressar um tipo composto (estrutura com um ou mais campos), voc\u00ea pode copiar os campos de outro tipo j\u00e1 existente no local. Para isso utilize ...NomeDoTipo dentro da defini\u00e7\u00e3o de uma estrutura, junto com os demais campos. Por exemplo: type BasicUser { id: uuid name: string } type User { email: string ...BasicUser friends: BasicUser[] } Neste exemplo o tipo User ter\u00e1 4 campos: email , id , name e friends . O operador ... far\u00e1 papel de copiar os campos de BasicUser para User . \u00c9 exatamente equivalente a escrever: type BasicUser { id: uuid name: string } type User { email: string id: uuid name: string friends: BasicUser[] } Um tipo pode conter m\u00faltiplos spreads. Caso um campo exista tanto no tipo atual quanto vindo do spread, o campo vindo do spread ser\u00e1 utilizado. Caso um mesmo campo apare\u00e7a em mais de um spread, a \u00faltima ocorr\u00eancia prevalecer\u00e1. Note que isso significa que um spread sempre substitui o campo do tipo, em caso de conflito. Exemplo: type A { foo: int } type B { foo: string } type C { bar: int } type Test1 { ...B ...A } type Test2 { ...C bar: string } Neste exemplo Test1 ter\u00e1 um campo foo de tipo int , j\u00e1 que ...A aparece por \u00faltimo. Test2 , por sua vez, ter\u00e1 um campo bar de tipo int , j\u00e1 que spreads sempre t\u00eam prioridade a campos locais.","title":"Spreads"},{"location":"descrevendo-api/#exemplo-final","text":"error NotFound type User { id: uuid avatar: url? name: string type: enum { guest fullUser admin } } fn getUser(id: uuid): User","title":"Exemplo final"},{"location":"faq/","text":"Problemas comuns \u00b6 TypeError: Class constructor BaseApiConfig cannot be invoked without 'new' \u00b6 O target para TypeScript em Node \u00e9 previamente compilado e distribu\u00eddo para ES2017, que j\u00e1 \u00e9 suportado por todas as vers\u00f5es n\u00e3o depreciadas do Node. No entanto o TypeScript por padr\u00e3o cria projetos para ES5, vers\u00e3o que somente \u00e9 \u00fatil quando visando browsers antigos como o Internet Explorer. A corre\u00e7\u00e3o mais simples \u00e9 modificar o tsconfig.json do seu projeto para uma vers\u00e3o do JavaScript igual ou maior que ES2017.","title":"Problemas comuns"},{"location":"faq/#problemas-comuns","text":"","title":"Problemas comuns"},{"location":"faq/#typeerror-class-constructor-baseapiconfig-cannot-be-invoked-without-new","text":"O target para TypeScript em Node \u00e9 previamente compilado e distribu\u00eddo para ES2017, que j\u00e1 \u00e9 suportado por todas as vers\u00f5es n\u00e3o depreciadas do Node. No entanto o TypeScript por padr\u00e3o cria projetos para ES5, vers\u00e3o que somente \u00e9 \u00fatil quando visando browsers antigos como o Internet Explorer. A corre\u00e7\u00e3o mais simples \u00e9 modificar o tsconfig.json do seu projeto para uma vers\u00e3o do JavaScript igual ou maior que ES2017.","title":"TypeError: Class constructor BaseApiConfig cannot be invoked without 'new'"},{"location":"primeiro-projeto/","text":"Primeiro projeto (em Node.js) \u00b6 Servidor \u00b6 Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript para ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias.","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#primeiro-projeto-em-nodejs","text":"","title":"Primeiro projeto (em Node.js)"},{"location":"primeiro-projeto/#servidor","text":"Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias: npm init -y npm i --save-dev typescript @sdkgen/cli npm i @sdkgen/node-runtime npx tsc --init -t esnext O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de api.sdkgen : type Post { id: uuid title: string body: string createdAt: datetime author: { name: string } } fn getPost(id: uuid): Post? Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace. A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript para ser a base da nossa aplica\u00e7\u00e3o chamado api.ts . Esse arquivo deve ser gerado novamente sempre que o api.sdkgen for modificado: npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de index.ts : import { SdkgenHttpServer } from \"@sdkgen/node-runtime\" ; import { api } from \"./api\" ; api . fn . getPost = async ( ctx , { id }) => { return { id , title : \"Primeira postagem\" , author : { name : \"John Doe\" , }, body : \"Lorem ipsum\" , createdAt : new Date (), }; }; const server = new SdkgenHttpServer ( api , {}); server . listen ( 8000 ); Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador. Ao fim, construa e execute a aplica\u00e7\u00e3o: npx tsc node index.js Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1. Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias.","title":"Servidor"},{"location":"releases/","text":"Releases \u00b6 1.5.5 (2021-02-22) \u00b6 Corre\u00e7\u00f5es: - Corre\u00e7\u00e3o no carregamento do /playground por conta de regress\u00e3o causada pela vers\u00e3o 1.5.4 ( #184 ). 1.5.4 (2021-02-19) \u00b6 Corre\u00e7\u00f5es: - Corre\u00e7\u00e3o no recebimento de objetos retornados pela API no browser-runtime ( #181 ). - Corre\u00e7\u00e3o no tratamento de rotas REST para que caso mais de uma rota encaixe com uma requisi\u00e7\u00e3o, aquela que cont\u00e9m a maior quantidade de caracteres que n\u00e3o fazem parte dos argumentos seja escolhida ( #179 ). - Mudan\u00e7a no tratamento de rotas REST de forma que argumentos do tipo string dentra da path n\u00e3o possam mais conter o caracter / ( #179 ). - Valida\u00e7\u00e3o de datas no browser-runtime e node-runtime de forma que uma data inv\u00e1lida n\u00e3o seja aceita ( #180 ). - Atualiza\u00e7\u00e3o de depend\u00eancias. 1.5.3 (2021-02-10) \u00b6 Corre\u00e7\u00e3o: - Ajustado o tipo TypeDescription utilizado para tipagem dos clientes em Node e Web com respeito ao enums. Esta release n\u00e3o inclui nenhuma altera\u00e7\u00e3o no comportamento durante execu\u00e7\u00e3o. 1.5.2 (2021-02-09) \u00b6 Corre\u00e7\u00e3o: - O tipo de retorno das fun\u00e7\u00f5es encode e decode do @sdkgen/node-runtime estava sendo incorretamente inferido quando o tipo possuia um enum. Essa tipagem foi corrigida. Esta release n\u00e3o inclui nenhuma altera\u00e7\u00e3o no comportamento durante execu\u00e7\u00e3o. 1.5.1 (2021-01-26) \u00b6 Nenhuma altera\u00e7\u00e3o. 1.5.0 (2021-01-26) \u00b6 Middlewares Agora \u00e9 poss\u00edvel adicionar m\u00faltiplos middlewares na configura\u00e7\u00e3o de uma API, possibilitando tomar a\u00e7\u00f5es a depender dos argumentos ou do retorno. api . use ( async ( ctx , next ) => { // Fa\u00e7a qualquer coisa com o `ctx` aqui. // O nome da fun\u00e7\u00e3o \u00e9 `ctx.request.name` e os argumentos `ctx.request.args`. const reply = await next (); // Fa\u00e7a qualquer coisa com a resposta aqui. return reply ; }); Os hooks anteriores de onRequestStart e onRequestEnd continuam funcionando, mas est\u00e3o agora depreciados. Voc\u00ea pode, por exemplo: Salvar os dados da requisi\u00e7\u00e3o e resposta em um log; Medir estat\u00edsticas das requisi\u00e7\u00f5es; Controlar rate limit; Bloquear ou redirecionar chamadas a depender da fun\u00e7\u00e3o e dos argumentos; Implementar cache; Implementar re-tentativa a depender de algum erro espec\u00edfico (chamando next mais de uma vez); Modificar o erro retornado ( try / catch em volta do next ). Ver #161 . Outras mudan\u00e7as Suporte ao Node.js 15 ( #115 ). Configura\u00e7\u00e3o do eslint renovada e tipagem mais forte em todos os pacotes TypeScript ( #166 ). Licen\u00e7a do projeto modificada para MIT ( #167 ). Atualiza\u00e7\u00e3o de depend\u00eancias. 1.4.4 (2021-01-26) \u00b6 Corre\u00e7\u00f5es Corre\u00e7\u00e3o no runtime do Flutter ao lan\u00e7ar erros do tipo SdkgenErrorWithData ( #175 ). 1.4.3 (2021-01-18) \u00b6 Corre\u00e7\u00f5es Gerador de c\u00f3digo do Flutter com erros que cont\u00e9m dados ( SdkgenErrorWithData ) agora produzem c\u00f3digo v\u00e1lido ( #171 ). Gerador de c\u00f3digo do Android agora utiliza SupervisorJob ( #168 ). 1.4.2 (2020-12-21) \u00b6 Corre\u00e7\u00f5es SdkgenErrorWithData n\u00e3o ser\u00e1 mais importado pelo c\u00f3digo gerado sem necessidade, evitando problemas com linter ( #141 ). Corre\u00e7\u00e3o na uso do WebpackManifestPlugin no playground. Corre\u00e7\u00e3o no syntax highlighting no Visual Studio Code para error ( #152 ). Corre\u00e7\u00e3o no processamento do tipo money no Flutter ( #153 ). C\u00f3digo duplicado removido ( #155 ). Corre\u00e7\u00e3o ao gerar classes de erro no Flutter ( #160 ). Corre\u00e7\u00e3o no processamento do tipo json no Flutter ( #159 ). Atualiza\u00e7\u00e3o de depend\u00eancias. 1.4.1 (2020-11-30) \u00b6 Corre\u00e7\u00f5es Corre\u00e7\u00e3o de regress\u00e3o na vers\u00e3o 1.4.0 em que o browser-runtime n\u00e3o retornava o conte\u00fado da resposta em caso de sucesso. Suporte ao tipo primitivo email no Swagger gerado para fun\u00e7\u00f5es @rest ( #140 ). Corre\u00e7\u00e3o de exemplo na documenta\u00e7\u00e3o ( #137 ). 1.4.0 (2020-11-19) \u00b6 Documenta\u00e7\u00e3o! ( #120 ) Temos agora uma documenta\u00e7\u00e3o nova e escrita em portugu\u00eas para o sdkgen. Ainda ser\u00e1 foco das pr\u00f3ximas releases para garantir que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para utilizar a manipular o sdkgen. Contribui\u00e7\u00f5es ser\u00e3o sempre bem-vindas. Confira em: https://sdkgen.github.io Dados adicionais em erros ( #133 ) No sdkgen sempre foi poss\u00edvel definir tipos de erro: error InvalidArgument Agora \u00e9 poss\u00edvel incluir dados adicionais (de qualquer tipo) junto com um erro: error InvalidArgument { argumentName: string reason: string } E o erro pode ser lan\u00e7ado como: throw new InvalidArgument(\"Argumento inv\u00e1lido!\", { argumentName: \"amount\", reason: \"Deve ser positivo\" }); Qualquer tipo pode ser utilizado, como por exemplo: error NoFunds uint? Outras mudan\u00e7as Lan\u00e7amento de erros no Node.js deve ser feito atrav\u00e9s de throw new SomeError(\"message\") em vez do api.err.SomeError(\"message\") . A forma anterior ainda est\u00e1 dispon\u00edvel, mas produzir\u00e1 um warning. ( #122 ) CLI est\u00e1 mais amig\u00e1vel com --help melhorado, inclusive no modo de checagem de compatibilidade sdkgen compatibility --help . ( #131 ) Suporte ao tipo xml no retorno de chamadas REST. ( #132 ) .NET 5.0 inclu\u00eddo no CI. ( #135 ) Atualiza\u00e7\u00e3o de depend\u00eancias. Corre\u00e7\u00f5es Informa\u00e7\u00f5es do dispositivo Android e iOS agora s\u00e3o corretamente reportadas no Flutter. ( #126 ) Colora\u00e7\u00e3o de sintaxe corrigida para @description e @arg com m\u00faltiplas linhas no VSCode. ( #128 ) Corre\u00e7\u00e3o no c\u00f3digo de status HTTP em requisi\u00e7\u00f5es REST em caso de erro Fatal. ( #130 ) Corre\u00e7\u00e3o no envio do tipo bytes como argumento de uma fun\u00e7\u00e3o no Android. ( #134 )","title":"Releases"},{"location":"releases/#releases","text":"","title":"Releases"},{"location":"releases/#155-2021-02-22","text":"Corre\u00e7\u00f5es: - Corre\u00e7\u00e3o no carregamento do /playground por conta de regress\u00e3o causada pela vers\u00e3o 1.5.4 ( #184 ).","title":"1.5.5 (2021-02-22)"},{"location":"releases/#154-2021-02-19","text":"Corre\u00e7\u00f5es: - Corre\u00e7\u00e3o no recebimento de objetos retornados pela API no browser-runtime ( #181 ). - Corre\u00e7\u00e3o no tratamento de rotas REST para que caso mais de uma rota encaixe com uma requisi\u00e7\u00e3o, aquela que cont\u00e9m a maior quantidade de caracteres que n\u00e3o fazem parte dos argumentos seja escolhida ( #179 ). - Mudan\u00e7a no tratamento de rotas REST de forma que argumentos do tipo string dentra da path n\u00e3o possam mais conter o caracter / ( #179 ). - Valida\u00e7\u00e3o de datas no browser-runtime e node-runtime de forma que uma data inv\u00e1lida n\u00e3o seja aceita ( #180 ). - Atualiza\u00e7\u00e3o de depend\u00eancias.","title":"1.5.4 (2021-02-19)"},{"location":"releases/#153-2021-02-10","text":"Corre\u00e7\u00e3o: - Ajustado o tipo TypeDescription utilizado para tipagem dos clientes em Node e Web com respeito ao enums. Esta release n\u00e3o inclui nenhuma altera\u00e7\u00e3o no comportamento durante execu\u00e7\u00e3o.","title":"1.5.3 (2021-02-10)"},{"location":"releases/#152-2021-02-09","text":"Corre\u00e7\u00e3o: - O tipo de retorno das fun\u00e7\u00f5es encode e decode do @sdkgen/node-runtime estava sendo incorretamente inferido quando o tipo possuia um enum. Essa tipagem foi corrigida. Esta release n\u00e3o inclui nenhuma altera\u00e7\u00e3o no comportamento durante execu\u00e7\u00e3o.","title":"1.5.2 (2021-02-09)"},{"location":"releases/#151-2021-01-26","text":"Nenhuma altera\u00e7\u00e3o.","title":"1.5.1 (2021-01-26)"},{"location":"releases/#150-2021-01-26","text":"Middlewares Agora \u00e9 poss\u00edvel adicionar m\u00faltiplos middlewares na configura\u00e7\u00e3o de uma API, possibilitando tomar a\u00e7\u00f5es a depender dos argumentos ou do retorno. api . use ( async ( ctx , next ) => { // Fa\u00e7a qualquer coisa com o `ctx` aqui. // O nome da fun\u00e7\u00e3o \u00e9 `ctx.request.name` e os argumentos `ctx.request.args`. const reply = await next (); // Fa\u00e7a qualquer coisa com a resposta aqui. return reply ; }); Os hooks anteriores de onRequestStart e onRequestEnd continuam funcionando, mas est\u00e3o agora depreciados. Voc\u00ea pode, por exemplo: Salvar os dados da requisi\u00e7\u00e3o e resposta em um log; Medir estat\u00edsticas das requisi\u00e7\u00f5es; Controlar rate limit; Bloquear ou redirecionar chamadas a depender da fun\u00e7\u00e3o e dos argumentos; Implementar cache; Implementar re-tentativa a depender de algum erro espec\u00edfico (chamando next mais de uma vez); Modificar o erro retornado ( try / catch em volta do next ). Ver #161 . Outras mudan\u00e7as Suporte ao Node.js 15 ( #115 ). Configura\u00e7\u00e3o do eslint renovada e tipagem mais forte em todos os pacotes TypeScript ( #166 ). Licen\u00e7a do projeto modificada para MIT ( #167 ). Atualiza\u00e7\u00e3o de depend\u00eancias.","title":"1.5.0 (2021-01-26)"},{"location":"releases/#144-2021-01-26","text":"Corre\u00e7\u00f5es Corre\u00e7\u00e3o no runtime do Flutter ao lan\u00e7ar erros do tipo SdkgenErrorWithData ( #175 ).","title":"1.4.4 (2021-01-26)"},{"location":"releases/#143-2021-01-18","text":"Corre\u00e7\u00f5es Gerador de c\u00f3digo do Flutter com erros que cont\u00e9m dados ( SdkgenErrorWithData ) agora produzem c\u00f3digo v\u00e1lido ( #171 ). Gerador de c\u00f3digo do Android agora utiliza SupervisorJob ( #168 ).","title":"1.4.3 (2021-01-18)"},{"location":"releases/#142-2020-12-21","text":"Corre\u00e7\u00f5es SdkgenErrorWithData n\u00e3o ser\u00e1 mais importado pelo c\u00f3digo gerado sem necessidade, evitando problemas com linter ( #141 ). Corre\u00e7\u00e3o na uso do WebpackManifestPlugin no playground. Corre\u00e7\u00e3o no syntax highlighting no Visual Studio Code para error ( #152 ). Corre\u00e7\u00e3o no processamento do tipo money no Flutter ( #153 ). C\u00f3digo duplicado removido ( #155 ). Corre\u00e7\u00e3o ao gerar classes de erro no Flutter ( #160 ). Corre\u00e7\u00e3o no processamento do tipo json no Flutter ( #159 ). Atualiza\u00e7\u00e3o de depend\u00eancias.","title":"1.4.2 (2020-12-21)"},{"location":"releases/#141-2020-11-30","text":"Corre\u00e7\u00f5es Corre\u00e7\u00e3o de regress\u00e3o na vers\u00e3o 1.4.0 em que o browser-runtime n\u00e3o retornava o conte\u00fado da resposta em caso de sucesso. Suporte ao tipo primitivo email no Swagger gerado para fun\u00e7\u00f5es @rest ( #140 ). Corre\u00e7\u00e3o de exemplo na documenta\u00e7\u00e3o ( #137 ).","title":"1.4.1 (2020-11-30)"},{"location":"releases/#140-2020-11-19","text":"Documenta\u00e7\u00e3o! ( #120 ) Temos agora uma documenta\u00e7\u00e3o nova e escrita em portugu\u00eas para o sdkgen. Ainda ser\u00e1 foco das pr\u00f3ximas releases para garantir que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para utilizar a manipular o sdkgen. Contribui\u00e7\u00f5es ser\u00e3o sempre bem-vindas. Confira em: https://sdkgen.github.io Dados adicionais em erros ( #133 ) No sdkgen sempre foi poss\u00edvel definir tipos de erro: error InvalidArgument Agora \u00e9 poss\u00edvel incluir dados adicionais (de qualquer tipo) junto com um erro: error InvalidArgument { argumentName: string reason: string } E o erro pode ser lan\u00e7ado como: throw new InvalidArgument(\"Argumento inv\u00e1lido!\", { argumentName: \"amount\", reason: \"Deve ser positivo\" }); Qualquer tipo pode ser utilizado, como por exemplo: error NoFunds uint? Outras mudan\u00e7as Lan\u00e7amento de erros no Node.js deve ser feito atrav\u00e9s de throw new SomeError(\"message\") em vez do api.err.SomeError(\"message\") . A forma anterior ainda est\u00e1 dispon\u00edvel, mas produzir\u00e1 um warning. ( #122 ) CLI est\u00e1 mais amig\u00e1vel com --help melhorado, inclusive no modo de checagem de compatibilidade sdkgen compatibility --help . ( #131 ) Suporte ao tipo xml no retorno de chamadas REST. ( #132 ) .NET 5.0 inclu\u00eddo no CI. ( #135 ) Atualiza\u00e7\u00e3o de depend\u00eancias. Corre\u00e7\u00f5es Informa\u00e7\u00f5es do dispositivo Android e iOS agora s\u00e3o corretamente reportadas no Flutter. ( #126 ) Colora\u00e7\u00e3o de sintaxe corrigida para @description e @arg com m\u00faltiplas linhas no VSCode. ( #128 ) Corre\u00e7\u00e3o no c\u00f3digo de status HTTP em requisi\u00e7\u00f5es REST em caso de erro Fatal. ( #130 ) Corre\u00e7\u00e3o no envio do tipo bytes como argumento de uma fun\u00e7\u00e3o no Android. ( #134 )","title":"1.4.0 (2020-11-19)"},{"location":"aprofundando/annotations/","text":"Annotations \u00b6 Al\u00e9m dos tipos e fun\u00e7\u00f5es descritas no arquivo \".sdkgen\", existem algumas anota\u00e7\u00f5es que voc\u00ea pode fazer sobre estes itens para indicar significado adicional. Cada uma tem caracter\u00edsticas diferentes e contextos diferentes em que podem ser aplicadas. Abaixo segue uma descri\u00e7\u00e3o detalhada de cada uma. @description \u00b6 A anota\u00e7\u00e3o @description pode aparecer antes de fun\u00e7\u00f5es, de tipos ou de campos. Ela tem o objetivo de adicionar uma documenta\u00e7\u00e3o sobre o item em quest\u00e3o, que aparecer\u00e1 no playground e em alguns targets gerados. Utilize para explicar o que uma fun\u00e7\u00e3o faz ou o significado de um campo. Alguns exemplos: @description Detalhes de um usu\u00e1rio. type User { @description Identificador \u00fanico. id: uuid @description Nome de apresenta\u00e7\u00e3o, escolhido pelo pr\u00f3prio usu\u00e1rio. name: string @description E-mail j\u00e1 validado do usu\u00e1rio. email: string? } @description Obt\u00e9m o usu\u00e1rio atual. Caso n\u00e3o tenha feito login, retornar\u00e1 null. fn getUser(): User? Essa descri\u00e7\u00e3o pode tamb\u00e9m ser multilinha atrav\u00e9s da adi\u00e7\u00e3o de um caractere \\ ao final da linha. Mas observe que n\u00e3o \u00e9 permitido duplicar anota\u00e7\u00f5es description no mesmo item. @description Retorna o pr\u00f3ximo pedido dispon\u00edvel para execu\u00e7\u00e3o. Essa fun\u00e7\u00e3o \\ pode ser chamada em paralelo por m\u00faltiplos clientes. Caso n\u00e3o haja um pedido \\ aguardando, a execu\u00e7\u00e3o ir\u00e1 pausar no servidor at\u00e9 que ou um pedido fique \\ dispon\u00edvel ou 2 minutos tenham se passado. Caso tenham passado 2 minutos sem \\ um pedido o retorno ser\u00e1 `null` e voc\u00ea deve chamar novamente. fn getNextOrder(): Order? @arg \u00b6 Similar ao @description , o @arg \u00e9 uma forma de documentar o significado de argumentos de fun\u00e7\u00f5es. @arg deve ser imediatamente seguido do nome do argumento e sua descri\u00e7\u00e3o, podendo envolver m\u00faltiplas linhas. Por exemplo: @description Buscar pedidos feitos pelo usu\u00e1rio atrav\u00e9s do ID. @arg id Identificador \u00fanico do pedido. @arg includeCanceled Caso deseje incluir pedidos que j\u00e1 foram cancelados \\ marcar como `true`, caso contr\u00e1rio utilize `false`. fn getOrder(id: uuid, includeCanceled: bool): Order @throws \u00b6 \u00c9 natural que fun\u00e7\u00f5es possam lan\u00e7ar erros. No sdkgen voc\u00ea deve definir quais erros existem ( error NotFound , por exemplo) e por padr\u00e3o qualquer fun\u00e7\u00e3o pode lan\u00e7ar qualquer erro. Este \u00e9 um padr\u00e3o simples, mas faz com que as fun\u00e7\u00f5es sejam pouco previs\u00edveis para os clientes que est\u00e3o chamando. Por isso \u00e9 recomendado que a anota\u00e7\u00e3o @throws seja utilizada nas fun\u00e7\u00f5es para marcar quais erros ela pode lan\u00e7ar durante a execu\u00e7\u00e3o. Essa anota\u00e7\u00e3o pode ser inclu\u00edda m\u00faltiplas vezes para especificar erros diferentes. Por exemplo: error NotFound error Forbidden error NoFunds @throws NotFound @throws Forbidden fn getUser(id: uuid) Neste exemplo a fun\u00e7\u00e3o getUser pode lan\u00e7ar o erro NotFound ou o erro Forbidden . Note que al\u00e9m desses dois, todas as fun\u00e7\u00f5es podem lan\u00e7ar o erro Fatal , quando o comportamento sai do esperado. Erros do tipo Fatal devem sempre ser considerados como bugs do backend. Caso a fun\u00e7\u00e3o tente lan\u00e7ar algum dos erros n\u00e3o mapeados, este ser\u00e1 convertido em Fatal para o cliente. @hidden \u00b6 Por padr\u00e3o todas as fun\u00e7\u00f5es podem ser chamadas no playground e s\u00e3o parte dos targets de clientes gerados. Caso uma fun\u00e7\u00e3o precise existir, mas n\u00e3o deva ser chamada normalmente, a anota\u00e7\u00e3o @hidden pode ser aplicada. As fun\u00e7\u00f5es ocultas n\u00e3o existir\u00e3o no playground ou nos target gerados, sendo \u00fatil para depreciar fun\u00e7\u00f5es antigas ou para marcar fun\u00e7\u00f5es para serem utilizadas exclusivamente como REST . Repare que fun\u00e7\u00f5es marcadas como @hidden ainda existem e ainda podem ser chamadas, especialmente por targets antigos. N\u00e3o use para efeitos de seguran\u00e7a. Exemplo: @hidden fn getUser(): User fn getUserV2(): UserV2 @rest \u00b6 Ver REST .","title":"Annotations"},{"location":"aprofundando/annotations/#annotations","text":"Al\u00e9m dos tipos e fun\u00e7\u00f5es descritas no arquivo \".sdkgen\", existem algumas anota\u00e7\u00f5es que voc\u00ea pode fazer sobre estes itens para indicar significado adicional. Cada uma tem caracter\u00edsticas diferentes e contextos diferentes em que podem ser aplicadas. Abaixo segue uma descri\u00e7\u00e3o detalhada de cada uma.","title":"Annotations"},{"location":"aprofundando/annotations/#description","text":"A anota\u00e7\u00e3o @description pode aparecer antes de fun\u00e7\u00f5es, de tipos ou de campos. Ela tem o objetivo de adicionar uma documenta\u00e7\u00e3o sobre o item em quest\u00e3o, que aparecer\u00e1 no playground e em alguns targets gerados. Utilize para explicar o que uma fun\u00e7\u00e3o faz ou o significado de um campo. Alguns exemplos: @description Detalhes de um usu\u00e1rio. type User { @description Identificador \u00fanico. id: uuid @description Nome de apresenta\u00e7\u00e3o, escolhido pelo pr\u00f3prio usu\u00e1rio. name: string @description E-mail j\u00e1 validado do usu\u00e1rio. email: string? } @description Obt\u00e9m o usu\u00e1rio atual. Caso n\u00e3o tenha feito login, retornar\u00e1 null. fn getUser(): User? Essa descri\u00e7\u00e3o pode tamb\u00e9m ser multilinha atrav\u00e9s da adi\u00e7\u00e3o de um caractere \\ ao final da linha. Mas observe que n\u00e3o \u00e9 permitido duplicar anota\u00e7\u00f5es description no mesmo item. @description Retorna o pr\u00f3ximo pedido dispon\u00edvel para execu\u00e7\u00e3o. Essa fun\u00e7\u00e3o \\ pode ser chamada em paralelo por m\u00faltiplos clientes. Caso n\u00e3o haja um pedido \\ aguardando, a execu\u00e7\u00e3o ir\u00e1 pausar no servidor at\u00e9 que ou um pedido fique \\ dispon\u00edvel ou 2 minutos tenham se passado. Caso tenham passado 2 minutos sem \\ um pedido o retorno ser\u00e1 `null` e voc\u00ea deve chamar novamente. fn getNextOrder(): Order?","title":"@description"},{"location":"aprofundando/annotations/#arg","text":"Similar ao @description , o @arg \u00e9 uma forma de documentar o significado de argumentos de fun\u00e7\u00f5es. @arg deve ser imediatamente seguido do nome do argumento e sua descri\u00e7\u00e3o, podendo envolver m\u00faltiplas linhas. Por exemplo: @description Buscar pedidos feitos pelo usu\u00e1rio atrav\u00e9s do ID. @arg id Identificador \u00fanico do pedido. @arg includeCanceled Caso deseje incluir pedidos que j\u00e1 foram cancelados \\ marcar como `true`, caso contr\u00e1rio utilize `false`. fn getOrder(id: uuid, includeCanceled: bool): Order","title":"@arg"},{"location":"aprofundando/annotations/#throws","text":"\u00c9 natural que fun\u00e7\u00f5es possam lan\u00e7ar erros. No sdkgen voc\u00ea deve definir quais erros existem ( error NotFound , por exemplo) e por padr\u00e3o qualquer fun\u00e7\u00e3o pode lan\u00e7ar qualquer erro. Este \u00e9 um padr\u00e3o simples, mas faz com que as fun\u00e7\u00f5es sejam pouco previs\u00edveis para os clientes que est\u00e3o chamando. Por isso \u00e9 recomendado que a anota\u00e7\u00e3o @throws seja utilizada nas fun\u00e7\u00f5es para marcar quais erros ela pode lan\u00e7ar durante a execu\u00e7\u00e3o. Essa anota\u00e7\u00e3o pode ser inclu\u00edda m\u00faltiplas vezes para especificar erros diferentes. Por exemplo: error NotFound error Forbidden error NoFunds @throws NotFound @throws Forbidden fn getUser(id: uuid) Neste exemplo a fun\u00e7\u00e3o getUser pode lan\u00e7ar o erro NotFound ou o erro Forbidden . Note que al\u00e9m desses dois, todas as fun\u00e7\u00f5es podem lan\u00e7ar o erro Fatal , quando o comportamento sai do esperado. Erros do tipo Fatal devem sempre ser considerados como bugs do backend. Caso a fun\u00e7\u00e3o tente lan\u00e7ar algum dos erros n\u00e3o mapeados, este ser\u00e1 convertido em Fatal para o cliente.","title":"@throws"},{"location":"aprofundando/annotations/#hidden","text":"Por padr\u00e3o todas as fun\u00e7\u00f5es podem ser chamadas no playground e s\u00e3o parte dos targets de clientes gerados. Caso uma fun\u00e7\u00e3o precise existir, mas n\u00e3o deva ser chamada normalmente, a anota\u00e7\u00e3o @hidden pode ser aplicada. As fun\u00e7\u00f5es ocultas n\u00e3o existir\u00e3o no playground ou nos target gerados, sendo \u00fatil para depreciar fun\u00e7\u00f5es antigas ou para marcar fun\u00e7\u00f5es para serem utilizadas exclusivamente como REST . Repare que fun\u00e7\u00f5es marcadas como @hidden ainda existem e ainda podem ser chamadas, especialmente por targets antigos. N\u00e3o use para efeitos de seguran\u00e7a. Exemplo: @hidden fn getUser(): User fn getUserV2(): UserV2","title":"@hidden"},{"location":"aprofundando/annotations/#rest","text":"Ver REST .","title":"@rest"},{"location":"aprofundando/datas/","text":"Comportamento de date e datetime \u00b6 Como descrito na sess\u00e3o sobre tipos primitivos , date e datetime possuem significados parecidos, mas fundamentalmente diferentes. Utilize datetime quando quiser se referir a um ponto no tempo ou date quando quiser se referir a uma data no calend\u00e1rio. Ponto no tempo: datetime \u00b6 Um ponto instant\u00e2neo no tempo deve ser o mesmo instante para todos os observadores, independente de onde eles est\u00e3o. Por conta disso o sdkgen sempre ir\u00e1 corrigir as varia\u00e7\u00f5es de timezone dos datetime s trocados entre as duas partes. Dessa forma uma das partes pode falar sobre um instante no tempo em seu fuso hor\u00e1rio local e o outro lado ir\u00e1 receber exatamente o mesmo instante, mas convertido no seu fuso hor\u00e1rio pr\u00f3prio. Esse comportamento \u00e9 conveniente ao trocar a informa\u00e7\u00e3o da data de publica\u00e7\u00e3o de uma postagem, por exemplo. Note que o \"inicio do dia\" e o \"fim do dia\" s\u00e3o momentos diferentes em fusos hor\u00e1rios diferentes. Data no calend\u00e1rio: date \u00b6 Um dia espec\u00edfico no calend\u00e1rio \u00e9 o mesmo em todo o globo, embora represente um intervalo de tempo diferente em cada fuso hor\u00e1rio. Datas ser\u00e3o passadas pelo sdkgen sem nenhuma altera\u00e7\u00e3o. Esse tipo \u00e9 \u00fatil para se referir a um feriado, ou a um intervalo de datas em um relat\u00f3rio financeiro. Como a maioria das linguagens n\u00e3o possui um tipo nativo para uma data, o mesmo tipo que datetime ser\u00e1 utilizado. O tempo ser\u00e1 recebido como se fosse o in\u00edcio do dia na sua timezone local. Lembre-se de tratar antes de utilizar. Por exemplo, caso esteja fazendo um filtro de datas, considere trocar a data final para \"fim do dia\" ou somar mais um dia, de forma que o intervalo seja inclusivo.","title":"date e datetime"},{"location":"aprofundando/datas/#comportamento-de-date-e-datetime","text":"Como descrito na sess\u00e3o sobre tipos primitivos , date e datetime possuem significados parecidos, mas fundamentalmente diferentes. Utilize datetime quando quiser se referir a um ponto no tempo ou date quando quiser se referir a uma data no calend\u00e1rio.","title":"Comportamento de date e datetime"},{"location":"aprofundando/datas/#ponto-no-tempo-datetime","text":"Um ponto instant\u00e2neo no tempo deve ser o mesmo instante para todos os observadores, independente de onde eles est\u00e3o. Por conta disso o sdkgen sempre ir\u00e1 corrigir as varia\u00e7\u00f5es de timezone dos datetime s trocados entre as duas partes. Dessa forma uma das partes pode falar sobre um instante no tempo em seu fuso hor\u00e1rio local e o outro lado ir\u00e1 receber exatamente o mesmo instante, mas convertido no seu fuso hor\u00e1rio pr\u00f3prio. Esse comportamento \u00e9 conveniente ao trocar a informa\u00e7\u00e3o da data de publica\u00e7\u00e3o de uma postagem, por exemplo. Note que o \"inicio do dia\" e o \"fim do dia\" s\u00e3o momentos diferentes em fusos hor\u00e1rios diferentes.","title":"Ponto no tempo: datetime"},{"location":"aprofundando/datas/#data-no-calendario-date","text":"Um dia espec\u00edfico no calend\u00e1rio \u00e9 o mesmo em todo o globo, embora represente um intervalo de tempo diferente em cada fuso hor\u00e1rio. Datas ser\u00e3o passadas pelo sdkgen sem nenhuma altera\u00e7\u00e3o. Esse tipo \u00e9 \u00fatil para se referir a um feriado, ou a um intervalo de datas em um relat\u00f3rio financeiro. Como a maioria das linguagens n\u00e3o possui um tipo nativo para uma data, o mesmo tipo que datetime ser\u00e1 utilizado. O tempo ser\u00e1 recebido como se fosse o in\u00edcio do dia na sua timezone local. Lembre-se de tratar antes de utilizar. Por exemplo, caso esteja fazendo um filtro de datas, considere trocar a data final para \"fim do dia\" ou somar mais um dia, de forma que o intervalo seja inclusivo.","title":"Data no calend\u00e1rio: date"},{"location":"aprofundando/rest/","text":"REST \u00b6 Em muitos casos queremos expor uma API para externos integrarem e nestes casos o formato REST \u00e9 um padr\u00e3o universalmente entendido e aceito, com boas ferramentas em todas as plataformas e linguagens. No sdkgen \u00e9 poss\u00edvel utilizar a annotation @rest para criar endpoints vinculados a suas fun\u00e7\u00f5es. Para criar uma fun\u00e7\u00e3o REST, inicie criando uma fun\u00e7\u00e3o normal do sdkgen, utilize quaisquer argumentos, tipo de retorno e nome que fizer sentido no seu caso de uso. Por exemplo: fn getPostsByUser(userId: uuid, since: datetime?, until: datetime?): Post[] Ent\u00e3o adicione a annotation @rest . Ela deve definir obrigatoriamente um m\u00e9todo e uma path, podendo incluir detalhamento adicional para os headers e body. Neste caso: @rest GET /users/{userId}/posts?{since}&{until} fn getPostsByUser(userId: uuid, since: datetime?, until: datetime?): Post[] Uma vez que exista ao menos 1 endpoint REST na sua aplica\u00e7\u00e3o, um Swagger UI ser\u00e1 criado automaticamente com a descri\u00e7\u00e3o do endpoint e documenta\u00e7\u00e3o atrav\u00e9s de @description e @arg . Para entender mais sobre como configurar este comportamento, leia a p\u00e1gina sobre um Servidor em Node.js . Caso queira que sua fun\u00e7\u00e3o esteja dispon\u00edvel exclusivamente como REST utilize @hidden . Anatomia do @rest \u00b6 @rest M\u00c9TODO /caminho/do/recurso/com/{arg1}/e/{arg2}?{argNaQuery1}&{argNaQuery2} [header Nome: {header}] [body {argBody}] Cada um dos elementos acima ser\u00e3o explicados nas pr\u00f3ximas sess\u00f5es. M\u00e9todo \u00b6 Os seguintes m\u00e9todos HTTP s\u00e3o suportados: GET , POST , PUT , DELETE e PATCH . Alguns exemplos: @rest GET /status fn getStatus(): bool @rest DELETE /product/{id} fn deleteProduct(id: uuid) @rest POST /product [body {newProduct}] fn createProduct(newProduct: Product): Product Caminho \u00b6 Logo ap\u00f3s o m\u00e9todo o segundo elemento obrigat\u00f3rio do @rest \u00e9 o caminho (ou \"endpoint\"). Este caminho deve come\u00e7ar com uma \"/\" e utilizar caracteres permitidos em uma URL. Neste caminho podem ser inclu\u00eddos alguns segmentos din\u00e2micos vinculados aos argumentos da fun\u00e7\u00e3o, como /product/{id} onde id \u00e9 um argumento. O caminho pode incluir m\u00faltiplos destes argumentos. Para um argumento poder ser utilizado dentro de um caminho ele deve ter um dos seguintes tipos: bool , int , uint , bigint , float , string , date , datetime , money , cpf , cnpj , uuid , hex , base64 ou ser um enum. Note que o tipo n\u00e3o pode ser nul\u00e1vel. Por exemplo: @rest GET /stores/{storeId}/products/{id} fn getProduct(storeId: uint, id: uint): Product? Neste caso uma chamada por GET /stores/3/products/47 ser\u00e1 similar a chamar getProduct(3, 47) . Argumentos tamb\u00e9m podem ser recebidos como parte da query . A query \u00e9 a parte da URL que vem depois do ? , por exemplo: GET /orders?state=open . Para estes argumentos especifique confirme o exemplo abaixo: @rest GET /stores/{storeId}/orders?{state}&{date} fn getOrders(storeId: uint, state: State?, date: date?): Order[] Neste caso a ordem dos argumentos n\u00e3o ser\u00e1 levada em considera\u00e7\u00e3o e os tipos aceitos s\u00e3o os mesmos que podem aparecer no caminho, com a exce\u00e7\u00e3o de que eles podem ser nul\u00e1veis. Neste caso \u00e9 comum (mas n\u00e3o obrigat\u00f3rio) que os argumentos sejam de fato nul\u00e1veis. Headers \u00b6 Em uma API REST pode ser necess\u00e1rio receber argumentos atrav\u00e9s de headers, especialmente em caso de autentica\u00e7\u00e3o. Para receber um header escreva conforme o seguinte exemplo: @rest GET /me [header Authorization: {token}] fn getCurrentUser(token: base64): User Os tipos permitidos s\u00e3o os mesmos listados para o caminho, podendo ser opcionais: bool , int , uint , bigint , float , string , date , datetime , money , cpf , cnpj , uuid , hex , base64 ou ser um enum. M\u00faltiplos headers podem ser especificados. Body \u00b6 Geralmente os m\u00e9todos POST , PUT e PATCH esperam que um body seja enviado na requisi\u00e7\u00e3o, embora um body possa ser enviado em qualquer m\u00e9todo. No sdkgen voc\u00ea pode encaminhar este body para um dos argumentos da fun\u00e7\u00e3o: type NewProduct { name: string } type Product { id: uuid ...NewProduct } @rest POST /products [body {newProduct}] fn createProduct(newProduct: NewProduct): Product Apenas um argumento pode ser o body da requisi\u00e7\u00e3o REST. Se o Content-Type tiver sido passado como application/json , ent\u00e3o o body ser\u00e1 lido conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Caso contr\u00e1rio o comportamento \u00e9 levemente diferente a depender do tipo do argumento: Tipo Comportamento qualquer nul\u00e1vel O argumento ser\u00e1 considerado null caso o body esteja em branco. bool \u00c9 esperado que o body seja literalmente true ou false . int , uint , bigint ou float O body seve conter apenas o n\u00famero, sem aspas. string , date , datetime , money , cpf , cnpj , uuid , hex ou base64 O conte\u00fado do body ser\u00e1 interpretado diretamente. N\u00e3o deve estar entre aspas. xml , bytes ou html Similar ao caso acima. O conte\u00fado do body ser\u00e1 passado tal como est\u00e1. json Um objeto JSON arbitr\u00e1rio ser\u00e1 esperado. qualquer enum O body dever\u00e1 ser um dos valores poss\u00edveis do enum, sem aspas. qualquer tipo composto O body ser\u00e1 lido conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Retorno \u00b6 A sua fun\u00e7\u00e3o pode retornar qualquer um dos tipos suportados pelo sdkgen. No entanto o comportamento exato ir\u00e1 variar a depender do tipo. C\u00f3digo de Status HTTP \u00b6 Situa\u00e7\u00e3o C\u00f3digo de Status Sucesso, mas com retorno null ou sem retorno e com m\u00e9todo GET 404 Not Found Sucesso, mas com retorno null ou sem retorno e outros m\u00e9todos 204 No Content Sucesso, com qualquer outro tipo de retorno 200 OK Erro lan\u00e7ado dentro da fun\u00e7\u00e3o diferente de Fatal 400 Bad Request Erro Fatal lan\u00e7ado dentro da fun\u00e7\u00e3o 500 Internal Server Error Erro n\u00e3o especificado durante o processamento da requisi\u00e7\u00e3o 500 Internal Server Error Codifica\u00e7\u00e3o do corpo da resposta \u00b6 Se a requisi\u00e7\u00e3o tiver passado o header Accept como application/json , ent\u00e3o o body ser\u00e1 gerado conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Caso contr\u00e1rio o comportamento ser\u00e1 dependente do tipo de retorno. Tipo Comportamento bool , int , uint , float , string , date , datetime , money , bigint , cpf , cnpj , uuid , hex ou base64 Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O Content-Type ser\u00e1 text/plain . html Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O Content-Type ser\u00e1 text/html . xml Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O Content-Type ser\u00e1 text/xml . bytes Os bytes ser\u00e3o entregues diretamente, ideal para oferecer download de arquivos. O Content-Type ser\u00e1 detectado dinamicamente a depender do conte\u00fado. Caso n\u00e3o seja poss\u00edvel detectar, ser\u00e1 application/octet-stream . outros tipos O body ser\u00e1 gerado conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen.","title":"REST"},{"location":"aprofundando/rest/#rest","text":"Em muitos casos queremos expor uma API para externos integrarem e nestes casos o formato REST \u00e9 um padr\u00e3o universalmente entendido e aceito, com boas ferramentas em todas as plataformas e linguagens. No sdkgen \u00e9 poss\u00edvel utilizar a annotation @rest para criar endpoints vinculados a suas fun\u00e7\u00f5es. Para criar uma fun\u00e7\u00e3o REST, inicie criando uma fun\u00e7\u00e3o normal do sdkgen, utilize quaisquer argumentos, tipo de retorno e nome que fizer sentido no seu caso de uso. Por exemplo: fn getPostsByUser(userId: uuid, since: datetime?, until: datetime?): Post[] Ent\u00e3o adicione a annotation @rest . Ela deve definir obrigatoriamente um m\u00e9todo e uma path, podendo incluir detalhamento adicional para os headers e body. Neste caso: @rest GET /users/{userId}/posts?{since}&{until} fn getPostsByUser(userId: uuid, since: datetime?, until: datetime?): Post[] Uma vez que exista ao menos 1 endpoint REST na sua aplica\u00e7\u00e3o, um Swagger UI ser\u00e1 criado automaticamente com a descri\u00e7\u00e3o do endpoint e documenta\u00e7\u00e3o atrav\u00e9s de @description e @arg . Para entender mais sobre como configurar este comportamento, leia a p\u00e1gina sobre um Servidor em Node.js . Caso queira que sua fun\u00e7\u00e3o esteja dispon\u00edvel exclusivamente como REST utilize @hidden .","title":"REST"},{"location":"aprofundando/rest/#anatomia-do-rest","text":"@rest M\u00c9TODO /caminho/do/recurso/com/{arg1}/e/{arg2}?{argNaQuery1}&{argNaQuery2} [header Nome: {header}] [body {argBody}] Cada um dos elementos acima ser\u00e3o explicados nas pr\u00f3ximas sess\u00f5es.","title":"Anatomia do @rest"},{"location":"aprofundando/rest/#metodo","text":"Os seguintes m\u00e9todos HTTP s\u00e3o suportados: GET , POST , PUT , DELETE e PATCH . Alguns exemplos: @rest GET /status fn getStatus(): bool @rest DELETE /product/{id} fn deleteProduct(id: uuid) @rest POST /product [body {newProduct}] fn createProduct(newProduct: Product): Product","title":"M\u00e9todo"},{"location":"aprofundando/rest/#caminho","text":"Logo ap\u00f3s o m\u00e9todo o segundo elemento obrigat\u00f3rio do @rest \u00e9 o caminho (ou \"endpoint\"). Este caminho deve come\u00e7ar com uma \"/\" e utilizar caracteres permitidos em uma URL. Neste caminho podem ser inclu\u00eddos alguns segmentos din\u00e2micos vinculados aos argumentos da fun\u00e7\u00e3o, como /product/{id} onde id \u00e9 um argumento. O caminho pode incluir m\u00faltiplos destes argumentos. Para um argumento poder ser utilizado dentro de um caminho ele deve ter um dos seguintes tipos: bool , int , uint , bigint , float , string , date , datetime , money , cpf , cnpj , uuid , hex , base64 ou ser um enum. Note que o tipo n\u00e3o pode ser nul\u00e1vel. Por exemplo: @rest GET /stores/{storeId}/products/{id} fn getProduct(storeId: uint, id: uint): Product? Neste caso uma chamada por GET /stores/3/products/47 ser\u00e1 similar a chamar getProduct(3, 47) . Argumentos tamb\u00e9m podem ser recebidos como parte da query . A query \u00e9 a parte da URL que vem depois do ? , por exemplo: GET /orders?state=open . Para estes argumentos especifique confirme o exemplo abaixo: @rest GET /stores/{storeId}/orders?{state}&{date} fn getOrders(storeId: uint, state: State?, date: date?): Order[] Neste caso a ordem dos argumentos n\u00e3o ser\u00e1 levada em considera\u00e7\u00e3o e os tipos aceitos s\u00e3o os mesmos que podem aparecer no caminho, com a exce\u00e7\u00e3o de que eles podem ser nul\u00e1veis. Neste caso \u00e9 comum (mas n\u00e3o obrigat\u00f3rio) que os argumentos sejam de fato nul\u00e1veis.","title":"Caminho"},{"location":"aprofundando/rest/#headers","text":"Em uma API REST pode ser necess\u00e1rio receber argumentos atrav\u00e9s de headers, especialmente em caso de autentica\u00e7\u00e3o. Para receber um header escreva conforme o seguinte exemplo: @rest GET /me [header Authorization: {token}] fn getCurrentUser(token: base64): User Os tipos permitidos s\u00e3o os mesmos listados para o caminho, podendo ser opcionais: bool , int , uint , bigint , float , string , date , datetime , money , cpf , cnpj , uuid , hex , base64 ou ser um enum. M\u00faltiplos headers podem ser especificados.","title":"Headers"},{"location":"aprofundando/rest/#body","text":"Geralmente os m\u00e9todos POST , PUT e PATCH esperam que um body seja enviado na requisi\u00e7\u00e3o, embora um body possa ser enviado em qualquer m\u00e9todo. No sdkgen voc\u00ea pode encaminhar este body para um dos argumentos da fun\u00e7\u00e3o: type NewProduct { name: string } type Product { id: uuid ...NewProduct } @rest POST /products [body {newProduct}] fn createProduct(newProduct: NewProduct): Product Apenas um argumento pode ser o body da requisi\u00e7\u00e3o REST. Se o Content-Type tiver sido passado como application/json , ent\u00e3o o body ser\u00e1 lido conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Caso contr\u00e1rio o comportamento \u00e9 levemente diferente a depender do tipo do argumento: Tipo Comportamento qualquer nul\u00e1vel O argumento ser\u00e1 considerado null caso o body esteja em branco. bool \u00c9 esperado que o body seja literalmente true ou false . int , uint , bigint ou float O body seve conter apenas o n\u00famero, sem aspas. string , date , datetime , money , cpf , cnpj , uuid , hex ou base64 O conte\u00fado do body ser\u00e1 interpretado diretamente. N\u00e3o deve estar entre aspas. xml , bytes ou html Similar ao caso acima. O conte\u00fado do body ser\u00e1 passado tal como est\u00e1. json Um objeto JSON arbitr\u00e1rio ser\u00e1 esperado. qualquer enum O body dever\u00e1 ser um dos valores poss\u00edveis do enum, sem aspas. qualquer tipo composto O body ser\u00e1 lido conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen.","title":"Body"},{"location":"aprofundando/rest/#retorno","text":"A sua fun\u00e7\u00e3o pode retornar qualquer um dos tipos suportados pelo sdkgen. No entanto o comportamento exato ir\u00e1 variar a depender do tipo.","title":"Retorno"},{"location":"aprofundando/rest/#codigo-de-status-http","text":"Situa\u00e7\u00e3o C\u00f3digo de Status Sucesso, mas com retorno null ou sem retorno e com m\u00e9todo GET 404 Not Found Sucesso, mas com retorno null ou sem retorno e outros m\u00e9todos 204 No Content Sucesso, com qualquer outro tipo de retorno 200 OK Erro lan\u00e7ado dentro da fun\u00e7\u00e3o diferente de Fatal 400 Bad Request Erro Fatal lan\u00e7ado dentro da fun\u00e7\u00e3o 500 Internal Server Error Erro n\u00e3o especificado durante o processamento da requisi\u00e7\u00e3o 500 Internal Server Error","title":"C\u00f3digo de Status HTTP"},{"location":"aprofundando/rest/#codificacao-do-corpo-da-resposta","text":"Se a requisi\u00e7\u00e3o tiver passado o header Accept como application/json , ent\u00e3o o body ser\u00e1 gerado conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Caso contr\u00e1rio o comportamento ser\u00e1 dependente do tipo de retorno. Tipo Comportamento bool , int , uint , float , string , date , datetime , money , bigint , cpf , cnpj , uuid , hex ou base64 Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O Content-Type ser\u00e1 text/plain . html Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O Content-Type ser\u00e1 text/html . xml Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O Content-Type ser\u00e1 text/xml . bytes Os bytes ser\u00e3o entregues diretamente, ideal para oferecer download de arquivos. O Content-Type ser\u00e1 detectado dinamicamente a depender do conte\u00fado. Caso n\u00e3o seja poss\u00edvel detectar, ser\u00e1 application/octet-stream . outros tipos O body ser\u00e1 gerado conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen.","title":"Codifica\u00e7\u00e3o do corpo da resposta"},{"location":"typescript_nodeserver/intro/","text":"Introdu\u00e7\u00e3o \u00b6 Target: typescript_nodeserver Maturidade: Est\u00e1vel Para criar um servidor em Node.js voc\u00ea deve criar um projeto em TypeScript e instalar o pacote npm @sdkgen/node-runtime . Instale tamb\u00e9m o @sdkgen/cli para ter acesso aos comandos de terminal para gerar c\u00f3digo. Descreva a sua API em arquivos .sdkgen . A sugest\u00e3o \u00e9 criar um arquivo api.sdkgen contendo as defini\u00e7\u00f5es ou importando os demais arquivos que cont\u00e9m essas defini\u00e7\u00f5es de tipos e fun\u00e7\u00f5es. Adicione este script ao seu package.json: { \"scripts\" : { \"sdkgen\" : \"sdkgen src/api.sdkgen -o src/api.ts -t typescript_nodeserver\" } } Com isso voc\u00ea poder\u00e1 executar npm run sdkgen para gerar novamente o arquivo src/api.ts a partir do src/api.sdkgen . Estrutura do arquivo gerado \u00b6 O arquivo api.ts gerado pelo sdkgen \u00e9 um m\u00f3dulo que importa @sdkgen/node-runtime (por isso precisa estar instalado) e exporta alguns tipos/objetos: Cada um dos enums e tipos compostos s\u00e3o definidos e exportados. Os tipos compostos s\u00e3o representados como interfaces e os enums como uni\u00e3o de strings literais dos seus valores poss\u00edveis. Para cada um dos erros definidos na descri\u00e7\u00e3o \u00e9 criada uma classe estendida a partir de Error para que voc\u00ea possa utilizar com throw . Uma classe ApiConfig com a qual voc\u00ea pode criar uma inst\u00e2ncia da configura\u00e7\u00e3o da API (descrito em mais detalhes abaixo). Uma constante nomeada api , que \u00e9 uma inst\u00e2ncia de ApiConfig .","title":"Introdu\u00e7\u00e3o"},{"location":"typescript_nodeserver/intro/#introducao","text":"Target: typescript_nodeserver Maturidade: Est\u00e1vel Para criar um servidor em Node.js voc\u00ea deve criar um projeto em TypeScript e instalar o pacote npm @sdkgen/node-runtime . Instale tamb\u00e9m o @sdkgen/cli para ter acesso aos comandos de terminal para gerar c\u00f3digo. Descreva a sua API em arquivos .sdkgen . A sugest\u00e3o \u00e9 criar um arquivo api.sdkgen contendo as defini\u00e7\u00f5es ou importando os demais arquivos que cont\u00e9m essas defini\u00e7\u00f5es de tipos e fun\u00e7\u00f5es. Adicione este script ao seu package.json: { \"scripts\" : { \"sdkgen\" : \"sdkgen src/api.sdkgen -o src/api.ts -t typescript_nodeserver\" } } Com isso voc\u00ea poder\u00e1 executar npm run sdkgen para gerar novamente o arquivo src/api.ts a partir do src/api.sdkgen .","title":"Introdu\u00e7\u00e3o"},{"location":"typescript_nodeserver/intro/#estrutura-do-arquivo-gerado","text":"O arquivo api.ts gerado pelo sdkgen \u00e9 um m\u00f3dulo que importa @sdkgen/node-runtime (por isso precisa estar instalado) e exporta alguns tipos/objetos: Cada um dos enums e tipos compostos s\u00e3o definidos e exportados. Os tipos compostos s\u00e3o representados como interfaces e os enums como uni\u00e3o de strings literais dos seus valores poss\u00edveis. Para cada um dos erros definidos na descri\u00e7\u00e3o \u00e9 criada uma classe estendida a partir de Error para que voc\u00ea possa utilizar com throw . Uma classe ApiConfig com a qual voc\u00ea pode criar uma inst\u00e2ncia da configura\u00e7\u00e3o da API (descrito em mais detalhes abaixo). Uma constante nomeada api , que \u00e9 uma inst\u00e2ncia de ApiConfig .","title":"Estrutura do arquivo gerado"},{"location":"typescript_nodeserver/middlewares/","text":"Middlewares \u00b6 Um middleware \u00e9 uma fun\u00e7\u00e3o registrada que intermedeia todas as chamadas. O conjunto de middlewares funciona como uma pilha em que o \u00faltimo middleware registrado \u00e9 o primeiro a receber a requisi\u00e7\u00e3o. Este pode manipular o ctx livremente e deve retornar uma resposta ou lan\u00e7ar um erro. O middleware pode opcionalmente chamar uma ou mais vezes o pr\u00f3ximo middleware atrav\u00e9s da fun\u00e7\u00e3o next recebida como argumento. A maioria dos middlewares ir\u00e1 chamar next exatamente uma vez, mas isso n\u00e3o \u00e9 uma regra. O retorno de next pode tamb\u00e9m ser manipulado antes de ser retornado. No fim da pilha o \u00faltimo middleware recebe uma fun\u00e7\u00e3o next que \u00e9 a pr\u00f3pria implementa\u00e7\u00e3o da execu\u00e7\u00e3o da chamada em quest\u00e3o, localizada no api.fn . Caso o nome da fun\u00e7\u00e3o em ctx.request.name tenha sido alterado, este ser\u00e1 chamado. api . use ( async ( ctx , next ) => { // Fa\u00e7a qualquer coisa com o `ctx` aqui. // O nome da fun\u00e7\u00e3o \u00e9 `ctx.request.name` e os argumentos `ctx.request.args`. const reply = await next (); // Fa\u00e7a qualquer coisa com a resposta aqui. return reply ; }); Voc\u00ea pode, por exemplo: Salvar os dados da requisi\u00e7\u00e3o e resposta em um log; Medir estat\u00edsticas das requisi\u00e7\u00f5es; Controlar rate limit; Bloquear ou redirecionar chamadas a depender da fun\u00e7\u00e3o e dos argumentos; Implementar cache; Implementar re-tentativa a depender de algum erro espec\u00edfico (chamando next mais de uma vez); Modificar o erro retornado ( try / catch em volta do next ).","title":"Middlewares"},{"location":"typescript_nodeserver/middlewares/#middlewares","text":"Um middleware \u00e9 uma fun\u00e7\u00e3o registrada que intermedeia todas as chamadas. O conjunto de middlewares funciona como uma pilha em que o \u00faltimo middleware registrado \u00e9 o primeiro a receber a requisi\u00e7\u00e3o. Este pode manipular o ctx livremente e deve retornar uma resposta ou lan\u00e7ar um erro. O middleware pode opcionalmente chamar uma ou mais vezes o pr\u00f3ximo middleware atrav\u00e9s da fun\u00e7\u00e3o next recebida como argumento. A maioria dos middlewares ir\u00e1 chamar next exatamente uma vez, mas isso n\u00e3o \u00e9 uma regra. O retorno de next pode tamb\u00e9m ser manipulado antes de ser retornado. No fim da pilha o \u00faltimo middleware recebe uma fun\u00e7\u00e3o next que \u00e9 a pr\u00f3pria implementa\u00e7\u00e3o da execu\u00e7\u00e3o da chamada em quest\u00e3o, localizada no api.fn . Caso o nome da fun\u00e7\u00e3o em ctx.request.name tenha sido alterado, este ser\u00e1 chamado. api . use ( async ( ctx , next ) => { // Fa\u00e7a qualquer coisa com o `ctx` aqui. // O nome da fun\u00e7\u00e3o \u00e9 `ctx.request.name` e os argumentos `ctx.request.args`. const reply = await next (); // Fa\u00e7a qualquer coisa com a resposta aqui. return reply ; }); Voc\u00ea pode, por exemplo: Salvar os dados da requisi\u00e7\u00e3o e resposta em um log; Medir estat\u00edsticas das requisi\u00e7\u00f5es; Controlar rate limit; Bloquear ou redirecionar chamadas a depender da fun\u00e7\u00e3o e dos argumentos; Implementar cache; Implementar re-tentativa a depender de algum erro espec\u00edfico (chamando next mais de uma vez); Modificar o erro retornado ( try / catch em volta do next ).","title":"Middlewares"}]}