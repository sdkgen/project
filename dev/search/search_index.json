{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Conhecendo o sdkgen","text":"<p>O sdkgen \u00e9 uma ferramenta voltada para desenhar e implementar API's ricas em recursos, mas com o m\u00ednimo de esfor\u00e7o para o desenvolvedor. O fluxo de trabalho envolve descrever os endpoints e tipos da API em uma linguagem tamb\u00e9m chamada sdkgen. Com essas descri\u00e7\u00f5es \u00e9 poss\u00edvel gerar c\u00f3digo para utilizar como servidor ou como cliente desta API, ambos os lados provendo garantias fortes de corretude dos dados trafegados.</p>"},{"location":"#recursos","title":"Recursos","text":"<ul> <li>Linguagem de descri\u00e7\u00e3o do contrato da API com tipagem forte.</li> <li>Bibliotecas para uso no servidor, facilitando a implementa\u00e7\u00e3o da API. Atualmente dispon\u00edvel em Node.js e .NET Core.</li> <li>Bibliotecas para uso no cliente, facilitando o consumo da API, com suporte \u00e0 Web, Android nativo, Node.js e Flutter.</li> <li>Um playground interativo para explorar e realizar chamadas.</li> <li>Cria\u00e7\u00e3o de endpoints em formato padr\u00e3o REST, incluindo Swagger autom\u00e1tico com 1 linha.</li> </ul>"},{"location":"#caracteristicas","title":"Caracter\u00edsticas","text":"<p>O principal foco do sdkgen est\u00e1 na simplicidade de uso e de entendimento, tentando sempre n\u00e3o causar surpresas e lidar com o maior n\u00famero poss\u00edvel de detalhes por conta pr\u00f3pria. Dito isso, o sdkgen se limita a ser um protocolo de transporte (assim como gRPC, REST ou GraphQL s\u00e3o), n\u00e3o interferindo na arquitetura do seu projeto.</p> <p>A linguagem do sdkgen permite descrever o contrato da sua API, por exemplo:</p> <pre><code>type User {\n  id: uuid\n  email: string\n  name: string\n}\n\nfn login(email: string, password: string): User\nfn logout()\nfn me(): User\n</code></pre> <p>Alguns tipos primitivos j\u00e1 est\u00e3o inclusos (como <code>string</code> e <code>uuid</code>), mas voc\u00ea pode definir tipos adicionais como <code>User</code> acima. H\u00e1 suporte para listas e opcionais tamb\u00e9m. Por fim fun\u00e7\u00f5es s\u00e3o definidas recebendo valores como argumentos e opcionalmente retornando dados. A descri\u00e7\u00e3o segue o formato de RPC (Remote Procedure Call) em que os clientes da API chamam essas fun\u00e7\u00f5es, recebendo as respostas de forma ass\u00edncrona. No servidor o corpo dessas fun\u00e7\u00f5es deve ser implementado. Todos os dados trafegados s\u00e3o validados nas duas pontas para garantir corretude.</p>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#instalando","title":"Instalando","text":"<p>Para uma instala\u00e7\u00e3o global utilize:</p> <pre><code>npm i -g @sdkgen/cli\n</code></pre> <p>Para instalar dentro do seu projeto Node corrente, utilize:</p> <pre><code>npm i --save-dev @sdkgen/cli\n</code></pre> <p>Neste caso voc\u00ea precisa chamar como <code>npx sdkgen</code> em vez de <code>sdkgen</code>.</p>"},{"location":"cli/#gerando-codigo","title":"Gerando c\u00f3digo","text":"<p>O uso prim\u00e1rio da CLI \u00e9 gerar c\u00f3digo fonte dos targets, seja de servidor ou de cliente. Para isso utilize a seguinte estrutura de comando:</p> <pre><code>sdkgen &lt;source file&gt; -o &lt;output file&gt; -t &lt;target name&gt;\n</code></pre> <p>Onde <code>&lt;source file&gt;</code> \u00e9 o seu arquivo <code>.sdkgen</code>, por exemplo <code>src/api.sdkgen</code>. <code>&lt;output file&gt;</code> \u00e9 o arquivo de destino, por exemplo <code>api.dart</code>. Por fim o <code>&lt;target name&gt;</code> se refere ao slug do target a ser utilizado, por exemplo <code>flutter</code>. Compondo este exemplo:</p> <pre><code>sdkgen src/api.sdkgen -o api.dart -t flutter\n</code></pre> <p>Estes s\u00e3o os target poss\u00edveis:</p>    Slug Descri\u00e7\u00e3o     csharp_server Servidor .NET, em C#   fsharp_server Servidor .NET, em F#   flutter Cliente para Flutter, em Dart   kotlin_android Cliente para Android nativo, em Kotlin   typescript_interfaces Apenas tipos da API, em TypeScript   typescript_nodeclient Cliente para Node.js, em TypeScript   typescript_nodeserver Servidor Node.js, em TypeScript   typescript_web Cliente para uso na Web, em TypeScript   swift_ios Cliente para iOS nativo, em Swift   rxswift_ios Cliente para iOS nativo, em Swift usando Rx"},{"location":"cli/#checagem-de-compatibilidade","title":"Checagem de compatibilidade","text":"<p>\u00c9 frequente precisar realizar altera\u00e7\u00f5es em uma API existente, seja adicionando novas fun\u00e7\u00f5es, novos campos, ou removendo itens. Nestes casos \u00e9 sempre preciso ter cuidado para n\u00e3o introduzir uma \"Breaking Change\", ou seja: uma altera\u00e7\u00e3o que seja inesperada pelos clientes existentes. Alguns exemplos de altera\u00e7\u00f5es que podem causar problemas:</p> <ul> <li>Remover ou renomear uma fun\u00e7\u00e3o;</li> <li>Adicionar um argumento n\u00e3o nul\u00e1vel;</li> <li>Adicionar um novo valor poss\u00edvel em um enum que \u00e9 retornado por uma fun\u00e7\u00e3o;</li> <li>Mudar um argumento de <code>string</code> para <code>uuid</code>.</li> </ul> <p>E altera\u00e7\u00f5es que podem serem feitas sem risco:</p> <ul> <li>Adicionar um novo campo em um objeto que \u00e9 retornado por uma fun\u00e7\u00e3o;</li> <li>Mudar a ordem dos argumentos de uma fun\u00e7\u00e3o;</li> <li>Adicionar novas fun\u00e7\u00f5es;</li> <li>Mudar um argumento de <code>uuid</code> para <code>string</code>.</li> </ul> <p>Estas regras podem rapidamente ficar complexas e s\u00e3o dif\u00edceis de checar por quem est\u00e1 escrevendo uma altera\u00e7\u00e3o em uma API existente. Por conta disso o sdkgen vem com uma ferramenta para checar compatibilidade entre altera\u00e7\u00f5es. Para isso utilize o seguinte comando:</p> <pre><code>sdkgen compatibility --old &lt;old source file&gt; --new &lt;new source file&gt;\n</code></pre> <p>Por exemplo:</p> <pre><code>sdkgen compatibility --old api_antiga.sdkgen --new api_nova.sdkgen\n</code></pre> <p>Caso existam quebras de compatibilidade estas ser\u00e3o reportadas.</p>"},{"location":"descrevendo-api/","title":"Descrevendo uma API","text":"<p>API's do sdkgen s\u00e3o descritas em um arquivo <code>.sdkgen</code>. O objetivo desta descri\u00e7\u00e3o \u00e9 firmar um contrato claro entre o que um front-end pode solicitar e receber e quais requisi\u00e7\u00f5es o back-end deve tratar. Todos os dados transferidos pela API precisam respeitar este contrato rigorosamente. No fim, tamb\u00e9m funciona como documenta\u00e7\u00e3o.</p>"},{"location":"descrevendo-api/#tipos","title":"Tipos","text":"<p>O primeiro passo para o entendimento de uma descri\u00e7\u00e3o de API do sdkgen \u00e9 compreender a gram\u00e1tica de tipos.</p>"},{"location":"descrevendo-api/#tipos-primitivos","title":"Tipos primitivos","text":"<p>O sdkgen possui alguns tipos primitivos, com diferentes regras e caracter\u00edsticas.</p>    Tipo Descri\u00e7\u00e3o     <code>string</code> Um texto livre, potencialmente de m\u00faltiplas linhas, codificado como UTF-8.   <code>int</code> Um n\u00famero inteiro de 32 bits, no intervalo de -2147483648 at\u00e9 2147483647.   <code>uint</code> Um n\u00famero inteiro n\u00e3o negativo, no intervalo de 0 at\u00e9 4294967295.   <code>bigint</code> Um n\u00famero inteiro sem limite de precis\u00e3o. Na maioria das plataformas este tipo \u00e9 mais custoso.   <code>float</code> Um n\u00famero de ponto flutuante de 64 bits, similar ao <code>double</code> do C.   <code>money</code> Um n\u00famero inteiro com precis\u00e3o estendida, mas perform\u00e1tico. Est\u00e1 no intervalo de -9007199254740991 a 9007199254740991. \u00datil para opera\u00e7\u00f5es financeiras.   <code>decimal</code> Um n\u00famero inteiro ou fracionado representado por d\u00edgitos decimais e com precis\u00e3o din\u00e2mica. \u00datil para opera\u00e7\u00f5es financeiras.   <code>bool</code> Ou <code>true</code> ou <code>false</code>.   <code>json</code> Um valor JSON qualquer, incluindo objetos, arrays, strings, n\u00fameros e boleanos, em qualquer profundidade. Note que embora <code>null</code> possa aparecer dentro de um objeto ou array, o valor deste campo n\u00e3o pode ser <code>null</code> diretamente. Para isso utilize <code>json?</code>.   <code>date</code> Representa conceitualmente uma data do calend\u00e1rio Gregoriano. Essa mesma data pode representar diferentes momento no tempo a depender da timezone. Para especificar um ponto no tempo utilize <code>datetime</code>.   <code>datetime</code> Representa um instante no tempo com precis\u00e3o de milissegundos. Este instante ser\u00e1 sempre traduzido para o fuso hor\u00e1rio local do recebedor da mensagem.   <code>bytes</code> Uma sequ\u00eancia arbitr\u00e1ria de bytes de qualquer comprimento. Pode ser utilizado para tr\u00e1fego de dados bin\u00e1rios.   <code>base64</code> Similar a uma <code>string</code>, mas necessariamente com uma codifica\u00e7\u00e3o Base 64 v\u00e1lida.   <code>url</code> Similar a uma <code>string</code>, mas contendo uma URL v\u00e1lida.   <code>hex</code> Similar a uma <code>string</code>, mas contendo uma quantidade par de caracteres hexadecimais, \u00fatil para representar bytes.   <code>uuid</code> Similar a uma <code>string</code>, mas contendo um UUID v\u00e1lido.   <code>email</code> Similar a uma <code>string</code>, mas contendo um e-mail v\u00e1lido.   <code>xml</code> Similar a uma <code>string</code>, mas contendo um XML v\u00e1lido.   <code>html</code> Similar a uma <code>string</code>, mas contendo um HTML v\u00e1lido.   <code>cpf</code> Similar a uma <code>string</code>, mas contendo um CPF v\u00e1lido.   <code>cnpj</code> Similar a uma <code>string</code>, mas contendo um CNPJ v\u00e1lido."},{"location":"descrevendo-api/#modificadores-de-tipo","title":"Modificadores de tipo","text":"<p>O sdkgen possui dois modificadores que podem ser sufixados em qualquer tipo: <code>?</code> e <code>[]</code>.</p> <p>Todos os tipos s\u00e3o por padr\u00e3o requeridos, com <code>null</code> n\u00e3o sendo um valor v\u00e1lido para nenhum deles. Um tipo pode se tornar nul\u00e1vel ao ser sufixado com <code>?</code>. Nesse caso ele ret\u00eam o seu comportamento original com a adi\u00e7\u00e3o de que <code>null</code> se torna um valor aceit\u00e1vel. Por exemplo: <code>string?</code> aceita qualquer texto livre ou <code>null</code>.</p> <p>O modificador <code>[]</code> pode ser adicionado ao final de qualquer tipo para criar uma lista deste tipo (um array, na maioria das linguagens). Estas listas podem ter zero ou mais repeti\u00e7\u00f5es deste tipo. Por exemplo: <code>cpf[]</code> denota uma lista de CPF's v\u00e1lidos.</p> <p>Esses dois modificadores podem ser combinados e repetidos livremente. Alguns exemplos: <code>int[]?</code> significa ou <code>null</code> ou uma lista de <code>int</code>'s. <code>string[][]</code> significa uma lista de listas de <code>string</code>'s. <code>bool?[]</code> significa uma lista de ou <code>true</code> ou <code>false</code> ou <code>null</code>.</p>"},{"location":"descrevendo-api/#tipos-compostos","title":"Tipos compostos","text":"<p>Objetos compostos podem ser constru\u00eddos, similar a classes, interfaces ou estruturas em outras linguagens. A sintaxe vem na forma de uma sequ\u00eancia de campos entre chaves, onde cada campo possui um nome e um tipo. Por exemplo:</p> <pre><code>{\n  name: string\n  age: uint\n}\n</code></pre> <p>Os campos podem vir em qualquer ordem desde de que n\u00e3o haja repeti\u00e7\u00e3o. Qualquer tipo \u00e9 v\u00e1lido em um campo, incluindo opcionais, listas ou outros objetos. Por exemplo:</p> <pre><code>{\n  id: uuid\n  name: string\n  avatar: url?\n  friends: {\n    id: uuid\n    name: string\n  }[]\n}\n</code></pre>"},{"location":"descrevendo-api/#enum","title":"Enum","text":"<p>Em adi\u00e7\u00e3o aos tipos anteriores um <code>enum</code> representa um conjunto limitado de possibilidades de valores, similar as enumera\u00e7\u00f5es em outras linguagens. A sintaxe inicia com a palavra chave <code>enum</code>, seguida por uma sequ\u00eancia de palavras entre chaves, separadas por espa\u00e7os ou quebras de linha. Por exemplo:</p> <pre><code>enum {\n  sent\n  received\n  failed\n}\n</code></pre> <p>Ou:</p> <pre><code>enum { small medium large }\n</code></pre> <p>Enums podem aparecer em qualquer posi\u00e7\u00e3o que um tipo pode, inclusive sendo opcional, lista ou parte de um tipo composto. Por exemplo:</p> <pre><code>{\n  name: string\n  skills: enum {\n    javascript\n    csharp\n    go\n  }[]\n}\n</code></pre>"},{"location":"descrevendo-api/#estrutura-de-um-arquivo-sdkgen","title":"Estrutura de um arquivo <code>.sdkgen</code>.","text":"<p>Em um arquivo <code>.sdkgen</code> voc\u00ea pode definir fun\u00e7\u00f5es, tipos nomeados e erros.</p>"},{"location":"descrevendo-api/#tipos-nomeados","title":"Tipos nomeados","text":"<p>Tipos nomeados podem ser criados com a sintaxe <code>type NomeDoTipo Tipo</code>. Por exemplo:</p> <pre><code>type PersonName string\n</code></pre> <p>Embora qualquer um dos tipos descritos acima possa aparece na defini\u00e7\u00e3o de um tipo nomeado, esta constru\u00e7\u00e3o \u00e9 muito mais comum com tipos compostos e enums. Por exemplo:</p> <pre><code>type Person {\n  name: string\n  age: uint\n}\n</code></pre> <p>Uma vez que um tipo nomeado tenha sido definido, o nome do tipo pode ser utilizado em qualquer lugar que receba um tipo. Por exemplo:</p> <pre><code>type UserType enum {\n  guest\n  fullUser\n  admin\n}\n\ntype User {\n  id: uuid\n  type: UserType\n  name: string\n}\n</code></pre> <p>Dessa maneira tipos podem ser combinados e utilizados m\u00faltiplas vezes sem repeti\u00e7\u00e3o. Um mesmo nome pode ser declarado mais de uma vez, desde que todas as declara\u00e7\u00f5es sejam id\u00eanticas. A ordem das declara\u00e7\u00f5es n\u00e3o tem import\u00e2ncia (a declara\u00e7\u00e3o do tipo pode aparecer depois do seu uso). Tipos, no entanto, n\u00e3o podem ser recursivos.</p>"},{"location":"descrevendo-api/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>A descri\u00e7\u00e3o das fun\u00e7\u00f5es \u00e9 provavelmente a parte mais importante da sua API. Toda fun\u00e7\u00e3o possui um nome, uma lista de argumentos e, opcionalmente, um tipo de retorno. Todas as fun\u00e7\u00f5es descritas estar\u00e3o expostas para serem chamadas por seus usu\u00e1rios, cabendo \u00e0 implementa\u00e7\u00e3o de sua API o trabalho de autenticar e autorizar acessos. Cada fun\u00e7\u00e3o deve possuir um nome claro que indique seu funcionamento, geralmente iniciando com um verbo.</p> <p>Exemplo da sintaxe:</p> <pre><code>fn addNumbers(first: int, second: int): int\n</code></pre> <p>Argumentos podem vir em qualquer quantidade e todos os tipos devem ser obrigatoriamente especificados. Caso um argumento seja opcional, utilize o modificador de tipo opcional <code>?</code> ao fim do tipo. O retorno da fun\u00e7\u00e3o pode ou n\u00e3o ser especificado. Caso n\u00e3o seja, a fun\u00e7\u00e3o n\u00e3o retornar\u00e1 nenhum valor.</p> <p>Todas as fun\u00e7\u00f5es descritas ser\u00e3o expostas nos c\u00f3digos gerados pelo sdkgen para cliente ou para servidor, na forma de fun\u00e7\u00f5es que retornam <code>Promise</code>, <code>Future</code> ou equivalente. O nome de cada fun\u00e7\u00e3o deve ser \u00fanico, n\u00e3o havendo suporte a sobrecarga de fun\u00e7\u00f5es (ou seja, n\u00e3o \u00e9 poss\u00edvel diferenciar duas fun\u00e7\u00f5es apenas pelo tipo de seus argumentos).</p>"},{"location":"descrevendo-api/#erros","title":"Erros","text":"<p>Toda API possui erros mapeados, seja por conta de um argumento passado incorretamente, por um recurso solicitado n\u00e3o existir ou por uma falha de um servi\u00e7o externo, por exemplo. \u00c9 importante que esses erros poss\u00edveis sejam tamb\u00e9m descritos para que um cliente n\u00e3o seja surpreendido. No sdkgen voc\u00ea pode declarar errors com a nota\u00e7\u00e3o <code>error NomeDoErro</code>. Por exemplo:</p> <pre><code>error InvalidArgument\nerror NotFound\n</code></pre> <p>A implementa\u00e7\u00e3o do servidor poder\u00e1 lan\u00e7ar esses erros ao longo da execu\u00e7\u00e3o e estes ser\u00e3o transmitidos ao cliente junto a uma mensagem de texto livre, de forma que o cliente possa tratar.</p> <p>Toda API sdkgen possui um erro impl\u00edcito de nome <code>Fatal</code>. Qualquer erro que seja lan\u00e7ado no servidor que n\u00e3o seja um dos erros descritos no contrato da API ser\u00e1 convertido em um erro de tipo <code>Fatal</code> antes de ser encaminhado ao cliente. Idealmente uma API nunca deve deixar escapar um erro <code>Fatal</code>.</p> <p>Um erro do sdkgen tamb\u00e9m pode possuir dados adicionais que ajudem a explicar o ocorrido. Esses dados podem ser de qualquer tipo (inclusive objetos) e ser\u00e3o trafegados para o cliente quando o backend lan\u00e7ar o erro. Exemplo:</p> <pre><code>error InvalidArgument {\n  argumentName: string\n  reason: string\n}\n\nerror RetryLater datetime\n</code></pre>"},{"location":"descrevendo-api/#importando-outros-arquivos","title":"Importando outros arquivos","text":"<p>Conforme uma API se torna maior e mais complexa passa a ser interessante dividir em m\u00faltiplos arquivos. Para isso a palavra-chave <code>import</code> pode ser utilizada. Por exemplo:</p> <pre><code>import \"../user\"\n</code></pre> <p>O significado desta linha \u00e9 buscar um arquivo chamado <code>../user.sdkgen</code> a partir da pasta atual. O <code>..</code> neste caso significa \"a pasta acima da pasta atual\". Qualquer caminho relativo ao arquivo atual pode ser passado e a extens\u00e3o do arquivo ( <code>.sdkgen</code>) n\u00e3o deve ser mencionada. O comportamento \u00e9 diretamente equivalente a copiar o conte\u00fado do arquivo e colar dentro do arquivo atual, na posi\u00e7\u00e3o do import. Cuidado para n\u00e3o incluir o mesmo arquivo mais de uma vez.</p>"},{"location":"descrevendo-api/#composicao-de-tipos","title":"Composi\u00e7\u00e3o de tipos","text":"<p>Tipos podem ser criados a partir de outros tipos j\u00e1 existentes. Atualmente o sdkgen suporta apenas um operador neste sentido, o spread.</p>"},{"location":"descrevendo-api/#spreads","title":"Spreads","text":"<p>Ao expressar um tipo composto (estrutura com um ou mais campos), voc\u00ea pode copiar os campos de outro tipo j\u00e1 existente no local. Para isso utilize <code>...NomeDoTipo</code> dentro da defini\u00e7\u00e3o de uma estrutura, junto com os demais campos. Por exemplo:</p> <pre><code>type BasicUser {\n  id: uuid\n  name: string\n}\n\ntype User {\n  email: string\n  ...BasicUser\n  friends: BasicUser[]\n}\n</code></pre> <p>Neste exemplo o tipo <code>User</code> ter\u00e1 4 campos: <code>email</code>, <code>id</code>, <code>name</code> e <code>friends</code>. O operador <code>...</code> far\u00e1 papel de copiar os campos de <code>BasicUser</code> para <code>User</code>. \u00c9 exatamente equivalente a escrever:</p> <pre><code>type BasicUser {\n  id: uuid\n  name: string\n}\n\ntype User {\n  email: string\n  id: uuid\n  name: string\n  friends: BasicUser[]\n}\n</code></pre> <p>Um tipo pode conter m\u00faltiplos spreads. Caso um campo exista tanto no tipo atual quanto vindo do spread, o campo vindo do spread ser\u00e1 utilizado. Caso um mesmo campo apare\u00e7a em mais de um spread, a \u00faltima ocorr\u00eancia prevalecer\u00e1. Note que isso significa que um spread sempre substitui o campo do tipo, em caso de conflito. Exemplo:</p> <pre><code>type A { foo: int }\ntype B { foo: string }\ntype C { bar: int }\n\ntype Test1 {\n  ...B\n  ...A\n}\n\ntype Test2 {\n  ...C\n  bar: string\n}\n</code></pre> <p>Neste exemplo <code>Test1</code> ter\u00e1 um campo <code>foo</code> de tipo <code>int</code>, j\u00e1 que <code>...A</code> aparece por \u00faltimo. <code>Test2</code>, por sua vez, ter\u00e1 um campo <code>bar</code> de tipo <code>int</code>, j\u00e1 que spreads sempre t\u00eam prioridade a campos locais.</p>"},{"location":"descrevendo-api/#exemplo-final","title":"Exemplo final","text":"<pre><code>error NotFound\n\ntype User {\n  id: uuid\n  avatar: url?\n  name: string\n  type: enum {\n    guest\n    fullUser\n    admin\n  }\n}\n\nfn getUser(id: uuid): User\n</code></pre>"},{"location":"faq/","title":"Problemas comuns","text":""},{"location":"faq/#typeerror-class-constructor-baseapiconfig-cannot-be-invoked-without-new","title":"TypeError: Class constructor BaseApiConfig cannot be invoked without 'new'","text":"<p>O target para TypeScript em Node \u00e9 previamente compilado e distribu\u00eddo para ES2017, que j\u00e1 \u00e9 suportado por todas as vers\u00f5es n\u00e3o depreciadas do Node. No entanto o TypeScript por padr\u00e3o cria projetos para ES5, vers\u00e3o que somente \u00e9 \u00fatil quando visando browsers antigos como o Internet Explorer. A corre\u00e7\u00e3o mais simples \u00e9 modificar o <code>tsconfig.json</code> do seu projeto para uma vers\u00e3o do JavaScript igual ou maior que ES2017.</p>"},{"location":"primeiro-projeto/","title":"Primeiro projeto (em Node.js)","text":""},{"location":"primeiro-projeto/#servidor","title":"Servidor","text":"<p>Vamos criar nosso primeiro projeto utilizando o sdkgen! Antes de qualquer coisa vamos inicializar nosso projeto e instalar depend\u00eancias:</p> <pre><code>npm init -y\nnpm i --save-dev typescript @sdkgen/cli\nnpm i @sdkgen/node-runtime\nnpx tsc --init -t esnext\n</code></pre> <p>O pr\u00f3ximo passo ser\u00e1 criar um arquivo de descri\u00e7\u00e3o da API. Nele voc\u00ea ir\u00e1 escrever todos os tipos customizados e as fun\u00e7\u00f5es de sua API. Vamos nomear de <code>api.sdkgen</code>:</p> <pre><code>type Post {\n  id: uuid\n  title: string\n  body: string\n  createdAt: datetime\n  author: {\n    name: string\n  }\n}\n\nfn getPost(id: uuid): Post?\n</code></pre>  <p>Se voc\u00ea usa o Visual Studio Code, esta pode ser uma boa hora para instalar a extens\u00e3o do sdkgen para sintaxe: Ver no Marketplace.</p>  <p>A partir deste arquivo de descri\u00e7\u00e3o devemos gerar um arquivo de c\u00f3digo TypeScript para ser a base da nossa aplica\u00e7\u00e3o chamado <code>api.ts</code>. Esse arquivo deve ser gerado novamente sempre que o <code>api.sdkgen</code> for modificado:</p> <pre><code>npx sdkgen api.sdkgen -o api.ts -t typescript_nodeserver\n</code></pre> <p>O arquivo gerado \u00e9 leg\u00edvel, mas n\u00e3o deve ser alterado por voc\u00ea, visto que as altera\u00e7\u00f5es ser\u00e3o perdidas na pr\u00f3xima vez que for gerado novamente. Agora voc\u00ea pode escrever o arquivo principal da sua aplica\u00e7\u00e3o, vamos chamar de <code>index.ts</code>:</p> <pre><code>import { SdkgenHttpServer } from \"@sdkgen/node-runtime\";\nimport { api } from \"./api\";\n\napi.fn.getPost = async (ctx, { id }) =&gt; {\n  return {\n    id,\n    title: \"Primeira postagem\",\n    author: {\n      name: \"John Doe\",\n    },\n    body: \"Lorem ipsum\",\n    createdAt: new Date(),\n  };\n};\n\nconst server = new SdkgenHttpServer(api, {});\nserver.listen(8000);\n</code></pre> <p>Neste exemplo temos a importa\u00e7\u00e3o do runtime espec\u00edfico de node e do arquivo gerado, em seguida a implementa\u00e7\u00e3o das fun\u00e7\u00f5es e por fim a cria\u00e7\u00e3o do servidor HTTP. Por ser TypeScript, tudo est\u00e1 apropriadamente tipado e \u00e9 checado pelo transpilador.</p> <p>Ao fim, construa e execute a aplica\u00e7\u00e3o:</p> <pre><code>npx tsc\nnode index.js\n</code></pre> <p>Com a aplica\u00e7\u00e3o rodando voc\u00ea pode abrir o playground no seu browser em: http://localhost:8000/playground. Experimente chamar a fun\u00e7\u00e3o l\u00e1.</p> <p>Para projetos pequenos essa estrutura \u00e9 suficiente, mas em outros casos \u00e9 interessante estruturar o projeto de forma a comportar uma API mais complexa, dividindo em m\u00faltiplos controllers, separando responsabilidades e facilitando inje\u00e7\u00e3o de depend\u00eancias.</p>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#220-2022-10-06","title":"2.2.0 (2022-10-06)","text":""},{"location":"releases/#funcionalidades","title":"Funcionalidades:","text":"<ul> <li>Adicionado o tipo <code>decimal</code> para armazenar n\u00fameros monet\u00e1rios com precis\u00e3o de casas decimais. Ver #724.</li> <li>Adicionado interceptadores de requisi\u00e7\u00f5es no target Flutter. Ver #725.</li> <li>Suporte ao Node.js 18. Removido suporte ao Node.js 12 e 17. Vers\u00f5es 14, 16 e 18 s\u00e3o suportadas. Ver #703.</li> <li>Adicionado suporte ao Flutter 3 e removido suporte ao Flutter 2. Ver #704.</li> <li>Permite customizar o fingerprint do dispositivo no target Android. Ver #734.</li> <li>Suporte a compilar m\u00faltiplos arquivos em um \u00fanico comando. Ver #690.</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul>"},{"location":"releases/#correcoes","title":"Corre\u00e7\u00f5es:","text":"<ul> <li>Corrigido suporte a executar em servi\u00e7os Serverless.</li> <li>Adicionado suporte ao tipo <code>json</code> em requisi\u00e7\u00f5es REST com Swagger.</li> <li>Outras corre\u00e7\u00f5es. Ver #684, #689.</li> <li>Corre\u00e7\u00e3o na ordem dos argumentos na path de uma requisi\u00e7\u00e3o REST. Ver #713.</li> <li>Ajustes no gerador do Flutter para produzir c\u00f3digo livre de alertas. Ver #726, #733.</li> </ul>"},{"location":"releases/#210-2022-05-09","title":"2.1.0 (2022-05-09)","text":"<ul> <li>Suporte a utilizar o sdkgen em servi\u00e7os Serverless (como Google Cloud Functions ou AWS Lambda), ou junto a servidores Node.js existentes, como o Express.js. Para tal basta criar uma inst\u00e2ncia do <code>SdkgenHttpServer</code> como usual, e ent\u00e3o registrar a propriedade <code>handleRequest</code> como fun\u00e7\u00e3o para receber requisi\u00e7\u00f5es HTTP. Ver detalhes na documenta\u00e7\u00e3o. Ver #678.</li> <li>Adicionado <code>ctx.response.headers</code> e <code>ctx.response.statusCode</code> para permitir modificar os headers e o status code da resposta de qualquer requisi\u00e7\u00e3o, especialmente \u00fatil para requisi\u00e7\u00f5es REST. Ver #676.</li> <li>Corre\u00e7\u00f5es na valida\u00e7\u00e3o de tipos quando mais de um tipo possui o mesmo nome em locais diferentes. Ver #672.</li> <li>Segundo argumento do <code>SdkgenHttpServer</code> agora \u00e9 opcional quando o <code>ExtraContext</code> n\u00e3o \u00e9 utilizado, simplificando o c\u00f3digo quando inje\u00e7\u00e3o de depend\u00eancia n\u00e3o \u00e9 necess\u00e1rio.</li> <li>Adicionado suporte ao ES2022 com TypeScript. Ver #682.</li> <li>Melhoria no di\u00e1logo de \"Sobre\" do playground. Ver #683.</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul> <p>As contribui\u00e7\u00f5es de 2 pessoas tornaram essa nova vers\u00e3o poss\u00edvel: @dgadelha e @lbguilherme.</p>"},{"location":"releases/#202-2022-03-14","title":"2.0.2 (2022-03-14)","text":"<ul> <li>Relan\u00e7amento da 2.0.1 para corre\u00e7\u00e3o de falha no processo de publica\u00e7\u00e3o.</li> </ul>"},{"location":"releases/#201-2022-03-07","title":"2.0.1 (2022-03-07)","text":"<ul> <li>Corre\u00e7\u00e3o no uso do playground em produ\u00e7\u00e3o.</li> <li>Corre\u00e7\u00e3o no tratamento da marca\u00e7\u00e3o <code>!secret</code> utilizada em conjunto com a anota\u00e7\u00e3o <code>@rest</code> (#659).</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul> <p>As contribui\u00e7\u00f5es de 4 pessoas tornaram essa nova vers\u00e3o poss\u00edvel: @dgadelha, @GuiBernal, @joshuapassos, e @lbguilherme.</p>"},{"location":"releases/#200-2022-02-07","title":"2.0.0 (2022-02-07)","text":"<p>Chegamos aqui com o sdkgen 2.0.0, ap\u00f3s quase 1 ano de desenvolvimento, trazendo muitas melhorias e novidades, com poucas mudan\u00e7as que podem impactar projetos. A expectativa \u00e9 que a atualiza\u00e7\u00e3o possa ser aplicada na maioria dos projetos sem nenhuma mudan\u00e7a de c\u00f3digo. \u00c9 sempre recomendado que o servidor atualize primeiro, antes dos clientes. Vamos ao que temos de novidades:</p> <p>Suporte ao Flutter 2 (sound null safety e Flutter Web)</p> <p>O Flutter 2 foi lan\u00e7ado junto ao Dart 1.12 e trouxeram o suporte opcional a tipos nul\u00e1veis, uma evolu\u00e7\u00e3o significativa. Uma boa parte do ecossistema j\u00e1 fez a migra\u00e7\u00e3o e o sdkgen agora est\u00e1 constru\u00eddo da mesma maneira. Tanto o c\u00f3digo gerado em Dart quanto o pacote <code>sdkgen_runtime</code> utilizam tipos nul\u00e1veis. Em complemento, Flutter Web \u00e9 suportado, assim como o Flutter para Android e iOS, oferecendo as mesmas funcionalidades.</p> <p>Um detalhe que facilita o uso nesta vers\u00e3o \u00e9 que anteriormente o SDK tinha que ser inicializado dentro de um widget passando acesso ao <code>BuildContext</code>. Isso n\u00e3o \u00e9 mais necess\u00e1rio e pode ser utilizado em qualquer lugar da aplica\u00e7\u00e3o, independente da UI.</p> <p>Cliente nativo em iOS (experimental)</p> <p>Um novo cliente nativo para iOS foi adicionado, junto ao gerador de c\u00f3digo em Swift. Ele pode ser utilizado com o target <code>swift_ios</code> ou <code>rxswift_ios</code> no gerador. Nesta vers\u00e3o esse target j\u00e1 \u00e9 funcional e suporta todos os recursos, no entanto ainda n\u00e3o foi testado o suficiente em produ\u00e7\u00e3o. Em caso de problemas, por favor reporte. Com teste suficiente acontecendo, poderemos marcar como est\u00e1vel em uma das pr\u00f3ximas vers\u00f5es.</p> <p>Servidor em F# (experimental)</p> <p>O suporte original para rodar sdkgen em .NET foi constru\u00eddo com base no .NET Core utilizando C#. Toda essa base foi reconstru\u00edda para dar espa\u00e7o a uma nova vers\u00e3o em F#, muito mais moderna e possibilitando ser utilizada tanto em projetos F# quanto em C#. A implementa\u00e7\u00e3o de m\u00e9todos \u00e9 f\u00e1cil e direta, assim como acontece em Node.js, mantendo a mesma simplicidade. Atualmente os recursos base do sdkgen s\u00e3o suportados, mas alguns opcionais n\u00e3o s\u00e3o suportados por este target, como suporte a REST e a compatibilidade com vers\u00f5es legadas. Est\u00e1 sendo lan\u00e7ado como experimental pois ainda n\u00e3o foi testado o suficiente em produ\u00e7\u00e3o. A expectativa \u00e9 lan\u00e7ar como vers\u00e3o est\u00e1vel e completa no futuro pr\u00f3ximo.</p> <p>Novo Playground</p> <p>O sdkgen possui um playgroud embutido desde a vers\u00e3o 1.0.0, possibilitando inspecionar uma API, conhecer as fun\u00e7\u00f5es dispon\u00edveis e invocar elas com dados para testar. Agora estamos incluindo um novo playground, com suporte a:</p> <ul> <li>Explorar as fun\u00e7\u00f5es existentes, junto com a documenta\u00e7\u00e3o do que fazem e os tipos que recebem ou retornam.</li> <li>Ver como a fun\u00e7\u00e3o deve ser chamada nas linguagens suportadas pelo sdkgen.</li> <li>Chamar as fun\u00e7\u00f5es, escrevendo os argumentos que deseja passar.</li> <li>Gerar e baixar o c\u00f3digo gerado em todos os targets suportados sem precisar instalar nada.</li> <li>Utilizar o editor avan\u00e7ado, em que \u00e9 poss\u00edvel escrever l\u00f3gica em JavaScript chamando uma ou mais fun\u00e7\u00f5es para executar diretamente em seu navegador.</li> </ul> <p>O novo playground pode ser utilizado inclusive com API's que ainda n\u00e3o foram atualizadas para o sdkgen 2.0.0.</p> <p>Acesse em: https://sdkgen.github.io/playground/ ou na rota <code>/playground</code> da sua API. \u00c9 necess\u00e1rio que <code>introspection</code> esteja habilitado.</p> <p>Uni\u00e3o de Tipos (experimental)</p> <p>Em muitos casos \u00e9 necess\u00e1rio que uma propriedade possa receber mais de um tipo de dado a depender da situa\u00e7\u00e3o, por exemplo quando uma lista de eventos \u00e9 retornada. At\u00e9 ent\u00e3o n\u00e3o havia uma boa forma de representar esses casos, mas agora o sdkgen suporta agregar dados adicionais no enum. Um exemplo de como isso pode ser utilizado:</p> <pre><code>type Event enum {\n  info(msg: string)\n  transaction(id: uuid, value: money, date: datetime, description: string)\n  refund(id: uuid)\n  ping\n}\n\nfn getEvents(): Event[]\n</code></pre> <p>Neste exemplo um <code>Event</code> pode ser qualquer um dos 4 tipos poss\u00edveis, a depender de qual seja, ele vir\u00e1 acompanhado de alguns dados adicionais. Com isso \u00e9 poss\u00edvel expressar cen\u00e1rios muito mais complexos de API's, sem precisar fazer rodeios.</p> <p>Atualmente esse modelo funciona em Node.js e na Web com TypeScript, mas ainda n\u00e3o est\u00e1 habilitado nos demais targets, por conta disso est\u00e1 marcado como experimental. Esperamos passar a fornecer em todas as linguagens no futuro.</p> <p>Tipos Recursivos</p> <p>Outro caso dif\u00edcil de expressar \u00e9 quando tipos precisam ser arbitrariamente recursivos. Por exemplo, observe o caso de coment\u00e1rios em uma postagem, sendo que um coment\u00e1rio pode ter outros coment\u00e1rios dentro. Agora \u00e9 poss\u00edvel declarar assim:</p> <pre><code>type Post {\n  body: string\n  authorId: uuid\n  comments: Comment[]\n}\n\ntype Comment {\n  body: string\n  authorId: uuid\n  comments: Comment[]\n}\n</code></pre> <p>Neste caso coment\u00e1rios podem conter coment\u00e1rios quantas vezes for necess\u00e1rio, usando um array vazio para representar um coment\u00e1rio que n\u00e3o tem outros coment\u00e1rios dentro. Tipos recursivos podem ser utilizados junto a uni\u00e3o de tipos tamb\u00e9m.</p> <p>Esperamos com isso aumentar a expressividade da descri\u00e7\u00e3o da API, representando cen\u00e1rios reais e evitando que o tipo <code>json</code> precise ser utilizado.</p> <p>Outras altera\u00e7\u00f5es</p> <p>Todos os recursos marcados como depreciados nas vers\u00f5es anteriores foram removidos. Se eram utilizados no seu projeto, precisar\u00e1 atualizar.</p> <p>Al\u00e9m disso foram aplicadas v\u00e1rias corre\u00e7\u00f5es e melhorias internas, deixando o projeto mais est\u00e1vel como um todo.</p> <p>Agradecimentos</p> <p>As contribui\u00e7\u00f5es de 13 pessoas tornaram esse lan\u00e7amento poss\u00edvel: @ahardmann, @danielpsantiago, @daniloapr, @davidcpires, @dgadelha, @elcioabrahao, @hofstede-matheus, @josecleiton, @joshuapassos, @lbguilherme, @manoellribeiro, @vhfmag, e @Yansb</p>"},{"location":"releases/#162-2021-10-27","title":"1.6.2 (2021-10-27)","text":"<ul> <li>Corre\u00e7\u00e3o do Swagger, regress\u00e3o causado na vers\u00e3o 1.5.0.</li> <li>Suporte ao tipo <code>bigint</code> no Playground e no Swagger.</li> </ul>"},{"location":"releases/#160-161-2021-09-29","title":"1.6.0 / 1.6.1 (2021-09-29)","text":"<ul> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> <li>Suporte ao .NET 6.0.</li> <li>Agora \u00e9 possivel o cliente enviar par\u00e2metros extras em requisi\u00e7\u00f5es ([#378])](https://github.com/sdkgen/sdkgen/pull/378)).</li> <li>Novo hook no browser-client para intercep\u00e7\u00e3o de erros ([#428])](https://github.com/sdkgen/sdkgen/pull/428)).</li> <li>Torna os HTTP Headers case insensitive.</li> <li>Remove console.error que estava aparecendo no runtime ([#556])](https://github.com/sdkgen/sdkgen/pull/556)).</li> </ul>"},{"location":"releases/#155-2021-02-22","title":"1.5.5 (2021-02-22)","text":"<p>Corre\u00e7\u00f5es:</p> <ul> <li>Corre\u00e7\u00e3o no carregamento do <code>/playground</code> por conta de regress\u00e3o causada pela vers\u00e3o 1.5.4 (#184).</li> </ul>"},{"location":"releases/#154-2021-02-19","title":"1.5.4 (2021-02-19)","text":"<p>Corre\u00e7\u00f5es:</p> <ul> <li>Corre\u00e7\u00e3o no recebimento de objetos retornados pela API no browser-runtime (#181).</li> <li>Corre\u00e7\u00e3o no tratamento de rotas REST para que caso mais de uma rota encaixe com uma requisi\u00e7\u00e3o, aquela que cont\u00e9m a maior quantidade de caracteres que n\u00e3o fazem parte dos argumentos seja escolhida (#179).</li> <li>Mudan\u00e7a no tratamento de rotas REST de forma que argumentos do tipo <code>string</code> dentra da path n\u00e3o possam mais conter o caracter <code>/</code> (#179).</li> <li>Valida\u00e7\u00e3o de datas no browser-runtime e node-runtime de forma que uma data inv\u00e1lida n\u00e3o seja aceita (#180).</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul>"},{"location":"releases/#153-2021-02-10","title":"1.5.3 (2021-02-10)","text":"<p>Corre\u00e7\u00e3o:</p> <ul> <li>Ajustado o tipo <code>TypeDescription</code> utilizado para tipagem dos clientes em Node e Web com respeito ao enums.</li> </ul> <p>Esta release n\u00e3o inclui nenhuma altera\u00e7\u00e3o no comportamento durante execu\u00e7\u00e3o.</p>"},{"location":"releases/#152-2021-02-09","title":"1.5.2 (2021-02-09)","text":"<p>Corre\u00e7\u00e3o:</p> <ul> <li>O tipo de retorno das fun\u00e7\u00f5es <code>encode</code> e <code>decode</code> do <code>@sdkgen/node-runtime</code> estava sendo incorretamente inferido quando o tipo possuia um enum. Essa tipagem foi corrigida.</li> </ul> <p>Esta release n\u00e3o inclui nenhuma altera\u00e7\u00e3o no comportamento durante execu\u00e7\u00e3o.</p>"},{"location":"releases/#151-2021-01-26","title":"1.5.1 (2021-01-26)","text":"<p>Nenhuma altera\u00e7\u00e3o.</p>"},{"location":"releases/#150-2021-01-26","title":"1.5.0 (2021-01-26)","text":"<p>Middlewares</p> <p>Agora \u00e9 poss\u00edvel adicionar m\u00faltiplos middlewares na configura\u00e7\u00e3o de uma API, possibilitando tomar a\u00e7\u00f5es a depender dos argumentos ou do retorno.</p> <pre><code>api.use(async (ctx, next) =&gt; {\n  // Fa\u00e7a qualquer coisa com o `ctx` aqui.\n  // O nome da fun\u00e7\u00e3o \u00e9 `ctx.request.name` e os argumentos `ctx.request.args`.\n  const reply = await next();\n  // Fa\u00e7a qualquer coisa com a resposta aqui.\n  return reply;\n});\n</code></pre> <p>Os hooks anteriores de <code>onRequestStart</code> e <code>onRequestEnd</code> continuam funcionando, mas est\u00e3o agora depreciados.</p> <p>Voc\u00ea pode, por exemplo:</p> <ul> <li>Salvar os dados da requisi\u00e7\u00e3o e resposta em um log;</li> <li>Medir estat\u00edsticas das requisi\u00e7\u00f5es;</li> <li>Controlar rate limit;</li> <li>Bloquear ou redirecionar chamadas a depender da fun\u00e7\u00e3o e dos argumentos;</li> <li>Implementar cache;</li> <li>Implementar re-tentativa a depender de algum erro espec\u00edfico (chamando <code>next</code> mais de uma vez);</li> <li>Modificar o erro retornado (<code>try</code>/<code>catch</code> em volta do <code>next</code>).</li> </ul> <p>Ver #161.</p> <p>Outras mudan\u00e7as</p> <ul> <li>Suporte ao Node.js 15 (#115).</li> <li>Configura\u00e7\u00e3o do eslint renovada e tipagem mais forte em todos os pacotes TypeScript (#166).</li> <li>Licen\u00e7a do projeto modificada para MIT (#167).</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul>"},{"location":"releases/#144-2021-01-26","title":"1.4.4 (2021-01-26)","text":"<p>Corre\u00e7\u00f5es</p> <ul> <li>Corre\u00e7\u00e3o no runtime do Flutter ao lan\u00e7ar erros do tipo <code>SdkgenErrorWithData</code> (#175).</li> </ul>"},{"location":"releases/#143-2021-01-18","title":"1.4.3 (2021-01-18)","text":"<p>Corre\u00e7\u00f5es</p> <ul> <li>Gerador de c\u00f3digo do Flutter com erros que cont\u00e9m dados (<code>SdkgenErrorWithData</code>) agora produzem c\u00f3digo v\u00e1lido (#171).</li> <li>Gerador de c\u00f3digo do Android agora utiliza <code>SupervisorJob</code> (#168).</li> </ul>"},{"location":"releases/#142-2020-12-21","title":"1.4.2 (2020-12-21)","text":"<p>Corre\u00e7\u00f5es</p> <ul> <li><code>SdkgenErrorWithData</code> n\u00e3o ser\u00e1 mais importado pelo c\u00f3digo gerado sem necessidade, evitando problemas com linter (#141).</li> <li>Corre\u00e7\u00e3o na uso do <code>WebpackManifestPlugin</code> no playground.</li> <li>Corre\u00e7\u00e3o no syntax highlighting no Visual Studio Code para <code>error</code> (#152).</li> <li>Corre\u00e7\u00e3o no processamento do tipo <code>money</code> no Flutter (#153).</li> <li>C\u00f3digo duplicado removido (#155).</li> <li>Corre\u00e7\u00e3o ao gerar classes de erro no Flutter (#160).</li> <li>Corre\u00e7\u00e3o no processamento do tipo <code>json</code> no Flutter (#159).</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul>"},{"location":"releases/#141-2020-11-30","title":"1.4.1 (2020-11-30)","text":"<p>Corre\u00e7\u00f5es</p> <ul> <li>Corre\u00e7\u00e3o de regress\u00e3o na vers\u00e3o 1.4.0 em que o browser-runtime n\u00e3o retornava o conte\u00fado da resposta em caso de sucesso.</li> <li>Suporte ao tipo primitivo <code>email</code> no Swagger gerado para fun\u00e7\u00f5es <code>@rest</code> (#140).</li> <li>Corre\u00e7\u00e3o de exemplo na documenta\u00e7\u00e3o (#137).</li> </ul>"},{"location":"releases/#140-2020-11-19","title":"1.4.0 (2020-11-19)","text":"<p>Documenta\u00e7\u00e3o! (#120)</p> <p>Temos agora uma documenta\u00e7\u00e3o nova e escrita em portugu\u00eas para o sdkgen. Ainda ser\u00e1 foco das pr\u00f3ximas releases para garantir que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para utilizar a manipular o sdkgen. Contribui\u00e7\u00f5es ser\u00e3o sempre bem-vindas.</p> <p>Confira em: https://sdkgen.github.io</p> <p>Dados adicionais em erros (#133)</p> <p>No sdkgen sempre foi poss\u00edvel definir tipos de erro:</p> <pre><code>error InvalidArgument\n</code></pre> <p>Agora \u00e9 poss\u00edvel incluir dados adicionais (de qualquer tipo) junto com um erro:</p> <pre><code>error InvalidArgument {\n  argumentName: string\n  reason: string\n}\n</code></pre> <p>E o erro pode ser lan\u00e7ado como:</p> <pre><code>throw new InvalidArgument(\"Argumento inv\u00e1lido!\", { argumentName: \"amount\", reason: \"Deve ser positivo\" });\n</code></pre> <p>Qualquer tipo pode ser utilizado, como por exemplo:</p> <pre><code>error NoFunds uint?\n</code></pre> <p>Outras mudan\u00e7as</p> <ul> <li>Lan\u00e7amento de erros no Node.js deve ser feito atrav\u00e9s de <code>throw new SomeError(\"message\")</code> em vez do <code>api.err.SomeError(\"message\")</code>. A forma anterior ainda est\u00e1 dispon\u00edvel, mas produzir\u00e1 um warning. (#122)</li> <li>CLI est\u00e1 mais amig\u00e1vel com <code>--help</code> melhorado, inclusive no modo de checagem de compatibilidade <code>sdkgen compatibility --help</code>. (#131)</li> <li>Suporte ao tipo <code>xml</code> no retorno de chamadas REST. (#132)</li> <li>.NET 5.0 inclu\u00eddo no CI. (#135)</li> <li>Atualiza\u00e7\u00e3o de depend\u00eancias.</li> </ul> <p>Corre\u00e7\u00f5es</p> <ul> <li>Informa\u00e7\u00f5es do dispositivo Android e iOS agora s\u00e3o corretamente reportadas no Flutter. (#126)</li> <li>Colora\u00e7\u00e3o de sintaxe corrigida para <code>@description</code> e <code>@arg</code> com m\u00faltiplas linhas no VSCode. (#128)</li> <li>Corre\u00e7\u00e3o no c\u00f3digo de status HTTP em requisi\u00e7\u00f5es REST em caso de erro Fatal. (#130)</li> <li>Corre\u00e7\u00e3o no envio do tipo <code>bytes</code> como argumento de uma fun\u00e7\u00e3o no Android. (#134)</li> </ul>"},{"location":"aprofundando/annotations/","title":"Annotations","text":"<p>Al\u00e9m dos tipos e fun\u00e7\u00f5es descritas no arquivo \".sdkgen\", existem algumas anota\u00e7\u00f5es que voc\u00ea pode fazer sobre estes itens para indicar significado adicional. Cada uma tem caracter\u00edsticas diferentes e contextos diferentes em que podem ser aplicadas. Abaixo segue uma descri\u00e7\u00e3o detalhada de cada uma.</p>"},{"location":"aprofundando/annotations/#description","title":"<code>@description</code>","text":"<p>A anota\u00e7\u00e3o <code>@description</code> pode aparecer antes de fun\u00e7\u00f5es, de tipos ou de campos. Ela tem o objetivo de adicionar uma documenta\u00e7\u00e3o sobre o item em quest\u00e3o, que aparecer\u00e1 no playground e em alguns targets gerados. Utilize para explicar o que uma fun\u00e7\u00e3o faz ou o significado de um campo. Alguns exemplos:</p> <pre><code>@description Detalhes de um usu\u00e1rio.\ntype User {\n  @description Identificador \u00fanico.\n  id: uuid\n\n  @description Nome de apresenta\u00e7\u00e3o, escolhido pelo pr\u00f3prio usu\u00e1rio.\n  name: string\n\n  @description E-mail j\u00e1 validado do usu\u00e1rio.\n  email: string?\n}\n\n@description Obt\u00e9m o usu\u00e1rio atual. Caso n\u00e3o tenha feito login, retornar\u00e1 null.\nfn getUser(): User?\n</code></pre> <p>Essa descri\u00e7\u00e3o pode tamb\u00e9m ser multilinha atrav\u00e9s da adi\u00e7\u00e3o de um caractere <code>\\</code> ao final da linha. Mas observe que n\u00e3o \u00e9 permitido duplicar anota\u00e7\u00f5es description no mesmo item.</p> <pre><code>@description Retorna o pr\u00f3ximo pedido dispon\u00edvel para execu\u00e7\u00e3o. Essa fun\u00e7\u00e3o \\\npode ser chamada em paralelo por m\u00faltiplos clientes. Caso n\u00e3o haja um pedido \\\naguardando, a execu\u00e7\u00e3o ir\u00e1 pausar no servidor at\u00e9 que ou um pedido fique \\\ndispon\u00edvel ou 2 minutos tenham se passado. Caso tenham passado 2 minutos sem \\\num pedido o retorno ser\u00e1 `null` e voc\u00ea deve chamar novamente.\nfn getNextOrder(): Order?\n</code></pre>"},{"location":"aprofundando/annotations/#arg","title":"<code>@arg</code>","text":"<p>Similar ao <code>@description</code>, o <code>@arg</code> \u00e9 uma forma de documentar o significado de argumentos de fun\u00e7\u00f5es. <code>@arg</code> deve ser imediatamente seguido do nome do argumento e sua descri\u00e7\u00e3o, podendo envolver m\u00faltiplas linhas. Por exemplo:</p> <pre><code>@description Buscar pedidos feitos pelo usu\u00e1rio atrav\u00e9s do ID.\n@arg id Identificador \u00fanico do pedido.\n@arg includeCanceled Caso deseje incluir pedidos que j\u00e1 foram cancelados \\\nmarcar como `true`, caso contr\u00e1rio utilize `false`.\nfn getOrder(id: uuid, includeCanceled: bool): Order\n</code></pre>"},{"location":"aprofundando/annotations/#throws","title":"<code>@throws</code>","text":"<p>\u00c9 natural que fun\u00e7\u00f5es possam lan\u00e7ar erros. No sdkgen voc\u00ea deve definir quais erros existem (<code>error NotFound</code>, por exemplo) e por padr\u00e3o qualquer fun\u00e7\u00e3o pode lan\u00e7ar qualquer erro. Este \u00e9 um padr\u00e3o simples, mas faz com que as fun\u00e7\u00f5es sejam pouco previs\u00edveis para os clientes que est\u00e3o chamando. Por isso \u00e9 recomendado que a anota\u00e7\u00e3o <code>@throws</code> seja utilizada nas fun\u00e7\u00f5es para marcar quais erros ela pode lan\u00e7ar durante a execu\u00e7\u00e3o. Essa anota\u00e7\u00e3o pode ser inclu\u00edda m\u00faltiplas vezes para especificar erros diferentes. Por exemplo:</p> <pre><code>error NotFound\nerror Forbidden\nerror NoFunds\n\n@throws NotFound\n@throws Forbidden\nfn getUser(id: uuid)\n</code></pre> <p>Neste exemplo a fun\u00e7\u00e3o <code>getUser</code> pode lan\u00e7ar o erro <code>NotFound</code> ou o erro <code>Forbidden</code>. Note que al\u00e9m desses dois, todas as fun\u00e7\u00f5es podem lan\u00e7ar o erro <code>Fatal</code>, quando o comportamento sai do esperado. Erros do tipo <code>Fatal</code> devem sempre ser considerados como bugs do backend. Caso a fun\u00e7\u00e3o tente lan\u00e7ar algum dos erros n\u00e3o mapeados, este ser\u00e1 convertido em <code>Fatal</code> para o cliente.</p>"},{"location":"aprofundando/annotations/#hidden","title":"<code>@hidden</code>","text":"<p>Por padr\u00e3o todas as fun\u00e7\u00f5es podem ser chamadas no playground e s\u00e3o parte dos targets de clientes gerados. Caso uma fun\u00e7\u00e3o precise existir, mas n\u00e3o deva ser chamada normalmente, a anota\u00e7\u00e3o <code>@hidden</code> pode ser aplicada. As fun\u00e7\u00f5es ocultas n\u00e3o existir\u00e3o no playground ou nos target gerados, sendo \u00fatil para depreciar fun\u00e7\u00f5es antigas ou para marcar fun\u00e7\u00f5es para serem utilizadas exclusivamente como REST. Repare que fun\u00e7\u00f5es marcadas como <code>@hidden</code> ainda existem e ainda podem ser chamadas, especialmente por targets antigos. N\u00e3o use para efeitos de seguran\u00e7a. Exemplo:</p> <pre><code>@hidden\nfn getUser(): User\n\nfn getUserV2(): UserV2\n</code></pre>"},{"location":"aprofundando/annotations/#rest","title":"<code>@rest</code>","text":"<p>Ver REST.</p>"},{"location":"aprofundando/datas/","title":"Comportamento de <code>date</code> e <code>datetime</code>","text":"<p>Como descrito na sess\u00e3o sobre tipos primitivos, <code>date</code> e <code>datetime</code> possuem significados parecidos, mas fundamentalmente diferentes. Utilize <code>datetime</code> quando quiser se referir a um ponto no tempo ou <code>date</code> quando quiser se referir a uma data no calend\u00e1rio.</p>"},{"location":"aprofundando/datas/#ponto-no-tempo-datetime","title":"Ponto no tempo: <code>datetime</code>","text":"<p>Um ponto instant\u00e2neo no tempo deve ser o mesmo instante para todos os observadores, independente de onde eles est\u00e3o. Por conta disso o sdkgen sempre ir\u00e1 corrigir as varia\u00e7\u00f5es de timezone dos <code>datetime</code>s trocados entre as duas partes. Dessa forma uma das partes pode falar sobre um instante no tempo em seu fuso hor\u00e1rio local e o outro lado ir\u00e1 receber exatamente o mesmo instante, mas convertido no seu fuso hor\u00e1rio pr\u00f3prio. Esse comportamento \u00e9 conveniente ao trocar a informa\u00e7\u00e3o da data de publica\u00e7\u00e3o de uma postagem, por exemplo.</p> <p>Note que o \"inicio do dia\" e o \"fim do dia\" s\u00e3o momentos diferentes em fusos hor\u00e1rios diferentes.</p>"},{"location":"aprofundando/datas/#data-no-calendario-date","title":"Data no calend\u00e1rio: <code>date</code>","text":"<p>Um dia espec\u00edfico no calend\u00e1rio \u00e9 o mesmo em todo o globo, embora represente um intervalo de tempo diferente em cada fuso hor\u00e1rio. Datas ser\u00e3o passadas pelo sdkgen sem nenhuma altera\u00e7\u00e3o. Esse tipo \u00e9 \u00fatil para se referir a um feriado, ou a um intervalo de datas em um relat\u00f3rio financeiro.</p> <p>Como a maioria das linguagens n\u00e3o possui um tipo nativo para uma data, o mesmo tipo que <code>datetime</code> ser\u00e1 utilizado. O tempo ser\u00e1 recebido como se fosse o in\u00edcio do dia na sua timezone local. Lembre-se de tratar antes de utilizar. Por exemplo, caso esteja fazendo um filtro de datas, considere trocar a data final para \"fim do dia\" ou somar mais um dia, de forma que o intervalo seja inclusivo.</p>"},{"location":"aprofundando/rest/","title":"REST","text":"<p>Em muitos casos queremos expor uma API para externos integrarem e nestes casos o formato REST \u00e9 um padr\u00e3o universalmente entendido e aceito, com boas ferramentas em todas as plataformas e linguagens. No sdkgen \u00e9 poss\u00edvel utilizar a annotation <code>@rest</code> para criar endpoints vinculados a suas fun\u00e7\u00f5es.</p> <p>Para criar uma fun\u00e7\u00e3o REST, inicie criando uma fun\u00e7\u00e3o normal do sdkgen, utilize quaisquer argumentos, tipo de retorno e nome que fizer sentido no seu caso de uso. Por exemplo:</p> <pre><code>fn getPostsByUser(userId: uuid, since: datetime?, until: datetime?): Post[]\n</code></pre> <p>Ent\u00e3o adicione a annotation <code>@rest</code>. Ela deve definir obrigatoriamente um m\u00e9todo e uma path, podendo incluir detalhamento adicional para os headers e body. Neste caso:</p> <pre><code>@rest GET /users/{userId}/posts?{since}&amp;{until}\nfn getPostsByUser(userId: uuid, since: datetime?, until: datetime?): Post[]\n</code></pre> <p>Uma vez que exista ao menos 1 endpoint REST na sua aplica\u00e7\u00e3o, um Swagger UI ser\u00e1 criado automaticamente com a descri\u00e7\u00e3o do endpoint e documenta\u00e7\u00e3o atrav\u00e9s de <code>@description</code> e <code>@arg</code>. Para entender mais sobre como configurar este comportamento, leia a p\u00e1gina sobre um Servidor em Node.js.</p> <p>Caso queira que sua fun\u00e7\u00e3o esteja dispon\u00edvel exclusivamente como REST utilize <code>@hidden</code>.</p>"},{"location":"aprofundando/rest/#anatomia-do-rest","title":"Anatomia do <code>@rest</code>","text":"<pre><code>@rest M\u00c9TODO /caminho/do/recurso/com/{arg1}/e/{arg2}?{argNaQuery1}&amp;{argNaQuery2} [header Nome: {header}] [body {argBody}]\n</code></pre> <p>Cada um dos elementos acima ser\u00e3o explicados nas pr\u00f3ximas sess\u00f5es.</p>"},{"location":"aprofundando/rest/#metodo","title":"M\u00e9todo","text":"<p>Os seguintes m\u00e9todos HTTP s\u00e3o suportados: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> e <code>PATCH</code>. Alguns exemplos:</p> <pre><code>@rest GET /status\nfn getStatus(): bool\n\n@rest DELETE /product/{id}\nfn deleteProduct(id: uuid)\n\n@rest POST /product [body {newProduct}]\nfn createProduct(newProduct: Product): Product\n</code></pre>"},{"location":"aprofundando/rest/#caminho","title":"Caminho","text":"<p>Logo ap\u00f3s o m\u00e9todo o segundo elemento obrigat\u00f3rio do <code>@rest</code> \u00e9 o caminho (ou \"endpoint\"). Este caminho deve come\u00e7ar com uma \"/\" e utilizar caracteres permitidos em uma URL. Neste caminho podem ser inclu\u00eddos alguns segmentos din\u00e2micos vinculados aos argumentos da fun\u00e7\u00e3o, como <code>/product/{id}</code> onde <code>id</code> \u00e9 um argumento. O caminho pode incluir m\u00faltiplos destes argumentos.</p> <p>Para um argumento poder ser utilizado dentro de um caminho ele deve ter um dos seguintes tipos: <code>bool</code>, <code>int</code>, <code>uint</code>, <code>bigint</code>, <code>float</code>, <code>string</code>, <code>date</code>, <code>datetime</code>, <code>money</code>, <code>decimal</code>, <code>cpf</code>, <code>cnpj</code>, <code>uuid</code>, <code>hex</code>, <code>base64</code> ou ser um enum. Note que o tipo n\u00e3o pode ser nul\u00e1vel.</p> <p>Por exemplo:</p> <pre><code>@rest GET /stores/{storeId}/products/{id}\nfn getProduct(storeId: uint, id: uint): Product?\n</code></pre> <p>Neste caso uma chamada por <code>GET /stores/3/products/47</code> ser\u00e1 similar a chamar <code>getProduct(3, 47)</code>.</p> <p>Argumentos tamb\u00e9m podem ser recebidos como parte da query. A query \u00e9 a parte da URL que vem depois do <code>?</code>, por exemplo: <code>GET /orders?state=open</code>. Para estes argumentos especifique confirme o exemplo abaixo:</p> <pre><code>@rest GET /stores/{storeId}/orders?{state}&amp;{date}\nfn getOrders(storeId: uint, state: State?, date: date?): Order[]\n</code></pre> <p>Neste caso a ordem dos argumentos n\u00e3o ser\u00e1 levada em considera\u00e7\u00e3o e os tipos aceitos s\u00e3o os mesmos que podem aparecer no caminho, com a exce\u00e7\u00e3o de que eles podem ser nul\u00e1veis. Neste caso \u00e9 comum (mas n\u00e3o obrigat\u00f3rio) que os argumentos sejam de fato nul\u00e1veis.</p>"},{"location":"aprofundando/rest/#headers","title":"Headers","text":"<p>Em uma API REST pode ser necess\u00e1rio receber argumentos atrav\u00e9s de headers, especialmente em caso de autentica\u00e7\u00e3o. Para receber um header escreva conforme o seguinte exemplo:</p> <pre><code>@rest GET /me [header Authorization: {token}]\nfn getCurrentUser(token: base64): User\n</code></pre> <p>Os tipos permitidos s\u00e3o os mesmos listados para o caminho, podendo ser opcionais: <code>bool</code>, <code>int</code>, <code>uint</code>, <code>bigint</code>, <code>float</code>, <code>string</code>, <code>date</code>, <code>datetime</code>, <code>money</code>, <code>decimal</code>, <code>cpf</code>, <code>cnpj</code>, <code>uuid</code>, <code>hex</code>, <code>base64</code> ou ser um enum. M\u00faltiplos headers podem ser especificados.</p>"},{"location":"aprofundando/rest/#body","title":"Body","text":"<p>Geralmente os m\u00e9todos <code>POST</code>, <code>PUT</code> e <code>PATCH</code> esperam que um body seja enviado na requisi\u00e7\u00e3o, embora um body possa ser enviado em qualquer m\u00e9todo. No sdkgen voc\u00ea pode encaminhar este body para um dos argumentos da fun\u00e7\u00e3o:</p> <pre><code>type NewProduct {\n  name: string\n}\n\ntype Product {\n  id: uuid\n  ...NewProduct\n}\n\n@rest POST /products [body {newProduct}]\nfn createProduct(newProduct: NewProduct): Product\n</code></pre> <p>Apenas um argumento pode ser o body da requisi\u00e7\u00e3o REST.</p> <p>Se o <code>Content-Type</code> tiver sido passado como <code>application/json</code>, ent\u00e3o o body ser\u00e1 lido conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Caso contr\u00e1rio o comportamento \u00e9 levemente diferente a depender do tipo do argumento:</p>    Tipo Comportamento     qualquer nul\u00e1vel O argumento ser\u00e1 considerado <code>null</code> caso o body esteja em branco.   <code>bool</code> \u00c9 esperado que o body seja literalmente <code>true</code> ou <code>false</code>.   <code>int</code>, <code>uint</code>, <code>bigint</code> ou <code>float</code> O body seve conter apenas o n\u00famero, sem aspas.   <code>string</code>, <code>date</code>, <code>datetime</code>, <code>money</code>, <code>decimal</code>, <code>cpf</code>, <code>cnpj</code>, <code>uuid</code>, <code>hex</code> ou <code>base64</code> O conte\u00fado do body ser\u00e1 interpretado diretamente. N\u00e3o deve estar entre aspas.   <code>xml</code>, <code>bytes</code> ou <code>html</code> Similar ao caso acima. O conte\u00fado do body ser\u00e1 passado tal como est\u00e1.   <code>json</code> Um objeto JSON arbitr\u00e1rio ser\u00e1 esperado.   qualquer enum O body dever\u00e1 ser um dos valores poss\u00edveis do enum, sem aspas.   qualquer tipo composto O body ser\u00e1 lido conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen."},{"location":"aprofundando/rest/#retorno","title":"Retorno","text":"<p>A sua fun\u00e7\u00e3o pode retornar qualquer um dos tipos suportados pelo sdkgen. No entanto o comportamento exato ir\u00e1 variar a depender do tipo.</p>"},{"location":"aprofundando/rest/#codigo-de-status-http","title":"C\u00f3digo de Status HTTP","text":"Situa\u00e7\u00e3o C\u00f3digo de Status     Sucesso, mas com retorno null ou sem retorno e com m\u00e9todo GET 404 Not Found   Sucesso, mas com retorno null ou sem retorno e outros m\u00e9todos 204 No Content   Sucesso, com qualquer outro tipo de retorno 200 OK   Erro lan\u00e7ado dentro da fun\u00e7\u00e3o diferente de Fatal 400 Bad Request   Erro Fatal lan\u00e7ado dentro da fun\u00e7\u00e3o 500 Internal Server Error   Erro n\u00e3o especificado durante o processamento da requisi\u00e7\u00e3o 500 Internal Server Error"},{"location":"aprofundando/rest/#codificacao-do-corpo-da-resposta","title":"Codifica\u00e7\u00e3o do corpo da resposta","text":"<p>Se a requisi\u00e7\u00e3o tiver passado o header <code>Accept</code> como <code>application/json</code>, ent\u00e3o o body ser\u00e1 gerado conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen. Caso contr\u00e1rio o comportamento ser\u00e1 dependente do tipo de retorno.</p>    Tipo Comportamento     <code>bool</code>, <code>int</code>, <code>uint</code>, <code>float</code>, <code>string</code>, <code>date</code>, <code>datetime</code>, <code>money</code>, <code>bigint</code>, <code>decimal</code>, <code>cpf</code>, <code>cnpj</code>, <code>uuid</code>, <code>hex</code> ou <code>base64</code> Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O <code>Content-Type</code> ser\u00e1 <code>text/plain</code>.   <code>html</code> Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O <code>Content-Type</code> ser\u00e1 <code>text/html</code>.   <code>xml</code> Valor ser\u00e1 posto diretamente no body, sem aspas adicionais. O <code>Content-Type</code> ser\u00e1 <code>text/xml</code>.   <code>bytes</code> Os bytes ser\u00e3o entregues diretamente, ideal para oferecer download de arquivos. O <code>Content-Type</code> ser\u00e1 detectado dinamicamente a depender do conte\u00fado. Caso n\u00e3o seja poss\u00edvel detectar, ser\u00e1 <code>application/octet-stream</code>.   outros tipos O body ser\u00e1 gerado conforme as regras de codifica\u00e7\u00e3o e decodifica\u00e7\u00e3o padr\u00f5es do sdkgen."},{"location":"typescript_nodeserver/intro/","title":"Introdu\u00e7\u00e3o","text":"<p>Target: <code>typescript_nodeserver</code>  Maturidade: Est\u00e1vel</p>  <p>Para criar um servidor em Node.js voc\u00ea deve criar um projeto em TypeScript e instalar o pacote npm <code>@sdkgen/node-runtime</code>. Instale tamb\u00e9m o <code>@sdkgen/cli</code> para ter acesso aos comandos de terminal para gerar c\u00f3digo. Descreva a sua API em arquivos <code>.sdkgen</code>. A sugest\u00e3o \u00e9 criar um arquivo <code>api.sdkgen</code> contendo as defini\u00e7\u00f5es ou importando os demais arquivos que cont\u00e9m essas defini\u00e7\u00f5es de tipos e fun\u00e7\u00f5es.</p> <p>Adicione este script ao seu package.json:</p> <pre><code>{\n  \"scripts\": {\n    \"sdkgen\": \"sdkgen src/api.sdkgen -o src/api.ts -t typescript_nodeserver\"\n  }\n}\n</code></pre> <p>Com isso voc\u00ea poder\u00e1 executar <code>npm run sdkgen</code> para gerar novamente o arquivo <code>src/api.ts</code> a partir do <code>src/api.sdkgen</code>.</p>"},{"location":"typescript_nodeserver/intro/#estrutura-do-arquivo-gerado","title":"Estrutura do arquivo gerado","text":"<p>O arquivo <code>api.ts</code> gerado pelo sdkgen \u00e9 um m\u00f3dulo que importa <code>@sdkgen/node-runtime</code> (por isso precisa estar instalado) e exporta alguns tipos/objetos:</p> <ul> <li>Cada um dos enums e tipos compostos s\u00e3o definidos e exportados. Os tipos compostos s\u00e3o representados como interfaces e os enums como uni\u00e3o de strings literais dos seus valores poss\u00edveis.</li> <li>Para cada um dos erros definidos na descri\u00e7\u00e3o \u00e9 criada uma classe estendida a partir de <code>Error</code> para que voc\u00ea possa utilizar com <code>throw</code>.</li> <li>Uma classe <code>ApiConfig</code> com a qual voc\u00ea pode criar uma inst\u00e2ncia da configura\u00e7\u00e3o da API (descrito em mais detalhes abaixo).</li> <li>Uma constante nomeada <code>api</code>, que \u00e9 uma inst\u00e2ncia de <code>ApiConfig</code>.</li> </ul>"},{"location":"typescript_nodeserver/intro/#uso-do-sdkgen-com-um-servidor-http-existente-ou-cloud-functions","title":"Uso do sdkgen com um servidor HTTP existente ou Cloud Functions","text":"<p>O sdkgen exp\u00f5e o m\u00e9todo <code>handleRequest</code> na sua inst\u00e2ncia do <code>SdkgenHttpServer</code>, abrindo a possibilidade de utilizar o sdkgen com um servidor HTTP existente, como o Express ou, ainda, com uma Cloud Function.</p> <pre><code>import { SdkgenHttpServer } from \"@sdkgen/node-runtime\";\nimport { createServer } from \"http\";\nimport { api } from \"./api\";\n\nconst sdkgenServer = new SdkgenHttpServer(api, {});\n\n// Primeira possibilidade: uso com um servidor HTTP existente:\nconst httpServer = createServer();\nhttpServer.on(\"request\", sdkgenServer.handleRequest);\nhttpServer.listen(8080);\n\n// Segunda possibilidade: uso com uma Cloud Function:\nexports.api = sdkgenServer.handleRequest; // Aqui, ser\u00e1 criada uma Cloud Function com o nome \"api\", que funciona normalmente como uma API em sdkgen.\n</code></pre>"},{"location":"typescript_nodeserver/middlewares/","title":"Middlewares","text":"<p>Um middleware \u00e9 uma fun\u00e7\u00e3o registrada que intermedeia todas as chamadas. O conjunto de middlewares funciona como uma pilha em que o \u00faltimo middleware registrado \u00e9 o primeiro a receber a requisi\u00e7\u00e3o. Este pode manipular o <code>ctx</code> livremente e deve retornar uma resposta ou lan\u00e7ar um erro. O middleware pode opcionalmente chamar uma ou mais vezes o pr\u00f3ximo middleware atrav\u00e9s da fun\u00e7\u00e3o <code>next</code> recebida como argumento. A maioria dos middlewares ir\u00e1 chamar <code>next</code> exatamente uma vez, mas isso n\u00e3o \u00e9 uma regra.</p> <p>O retorno de <code>next</code> pode tamb\u00e9m ser manipulado antes de ser retornado. No fim da pilha o \u00faltimo middleware recebe uma fun\u00e7\u00e3o <code>next</code> que \u00e9 a pr\u00f3pria implementa\u00e7\u00e3o da execu\u00e7\u00e3o da chamada em quest\u00e3o, localizada no <code>api.fn</code>. Caso o nome da fun\u00e7\u00e3o em <code>ctx.request.name</code> tenha sido alterado, este ser\u00e1 chamado.</p> <pre><code>api.use(async (ctx, next) =&gt; {\n  // Fa\u00e7a qualquer coisa com o `ctx` aqui.\n  // O nome da fun\u00e7\u00e3o \u00e9 `ctx.request.name` e os argumentos `ctx.request.args`.\n  const reply = await next();\n  // Fa\u00e7a qualquer coisa com a resposta aqui.\n  return reply;\n});\n</code></pre> <p>Voc\u00ea pode, por exemplo:</p> <ul> <li>Salvar os dados da requisi\u00e7\u00e3o e resposta em um log;</li> <li>Medir estat\u00edsticas das requisi\u00e7\u00f5es;</li> <li>Controlar rate limit;</li> <li>Bloquear ou redirecionar chamadas a depender da fun\u00e7\u00e3o e dos argumentos;</li> <li>Implementar cache;</li> <li>Implementar re-tentativa a depender de algum erro espec\u00edfico (chamando <code>next</code> mais de uma vez);</li> <li>Modificar o erro retornado (<code>try</code>/<code>catch</code> em volta do <code>next</code>).</li> </ul>"}]}